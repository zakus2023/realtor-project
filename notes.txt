# npm install --global yarn in the main folder
# cd api
# yarn init and then follow the prompts
# yarn add cookie-parser cors dotenv express express-async-handler express-oauth2-jwt-bearer nodemon prisma @prima/
- in the api folder create a file called index.js and the .env file


INITIAL index.js content
==============================
import express from "express";
import dotenv from "dotenv";
import cookieParser from "cookie-parser";
import cors from "cors";

const port = 5000

dotenv.config();

const app = express();
app.use(express.json())
app.use(cookieParser())
app.use(cors())


app.listen(port, ()=>{
    console.log("Sever is listening on port "+ port)
})
=============================================

after that  # yarn run start

- create a folder in the api folder called prisma and create a file called schema.prisma in the folder
    - note: prisma will be used to abstract our database layer
    - also remeber to install the prisma extension in the vscode

    Hereâ€™s your Prisma schema with comprehensive comments explaining each part:


    // The `generator` block defines the Prisma Client, which is used to interact with the database.
    generator client {
        provider = "prisma-client-js" // Specifies that Prisma Client for JavaScript should be generated.
    }

    // The `datasource` block specifies the database connection description.
    datasource db {
        provider = "mongodb" // Sets MongoDB as the database provider.
        url = env("DATABASE_URL") // Reads the database URL from environment variables.
    }

    // Defines the `User` model representing users in the database.
    model User {
        id String @id @default(auto()) @map("_id") @db.ObjectId // Unique identifier, automatically generated, mapped to MongoDB `_id`.
        name String? // Optional name of the user.
        email String @unique // User's email, must be unique.
        image String? // Optional profile image URL.
        bookedVisit Json[] // Stores an array of booked visits as JSON data.
        favResidenciesiD String[] @db.ObjectId // Array of ObjectIds referring to favorite residencies.
        ownedResidencies Residency[] @relation("Owner") // One-to-many relation with the `Residency` model, where the user owns multiple residencies.
    }

    // Defines the `Residency` model representing properties available for booking.
    model Residency {
        id String @id @default(auto()) @map("_id") @db.ObjectId // Unique identifier, automatically generated, mapped to MongoDB `_id`.
        title String // Title of the residency.
        description String // Description of the residency.
        price Int // Price of the residency.
        address String // Address of the residency.
        city String // City where the residency is located.
        country String // Country where the residency is located.
        image String // Image URL for the residency.
        facilities Json // Stores residency facilities as JSON data.
        userEmail String // Stores the email of the user who owns the residency.
        owner User @relation("Owner", fields: [userEmail], references: [email]) 
        // Establishes a relationship with the `User` model, linking the residency to its owner via the user's email.

        createdAt DateTime @default(now()) // Automatically sets the creation timestamp.
        updatedAt DateTime @updatedAt // Automatically updates the timestamp when the record is modified.
    }

    Summary of Key Features:
    ==========================
    @id @default(auto()) @map("_id") @db.ObjectId: Ensures that MongoDB _id is used as the primary key.
    Relationships:
    A user can own multiple residencies (ownedResidencies).
    Residency is linked to User through the userEmail field.
    Automatic timestamps:
    createdAt defaults to the current time.
    updatedAt updates automatically when a record is modified.
    JSON fields (bookedVisit, facilities): Stores flexible data structures.
    This schema is optimized for a MongoDB-based application with user-owned properties. ðŸš€
NOTE:whiles the server is still running: In the api folder run:  npx prisma db push and   npx prisma generate

- Create a folder called config in the api folder
    - create a file called prismaConfig.js in the folder created above
- create a folder called controllers in the api folder
    - create a file called userController.js in the controllers folder
    - create a file called residenceController.js in the controllers folder
- create a folder called routes in the api folder
    - create a file called userRoute.js in the routes folder
    - create a file called residenceRoute.js in the routes folder


NB: To add data from a json file to the mongodb database
    - create a folder in the api folder called data
    - add the json file to its
    - go to https://www.mongodb.com/try/download/database-tools
    - scroll to MongoDB Command Line Database Tools Download under Tools
    - extract the file
    - open the bin folder and copy the Residency.json file into its
    - open the folder in Command Line Interface (cmd)
    - write the following command: ./mongoimport --uri mongodb+srv://userCorrect:qwertyC3600@mycluster.janfs9e.mongodb.net/aetherestate --collection Residency --type json --jsonArray --file Residency.json

    FRONT END/CLIENT
    ==================
    - for using an already existing frontend
    - I first downloaded the frontend starter pack
    - Then i created a repository on github
    - then i cd into the client folder and run the following commands
        - yarn
        - yarn run dev
    
    Starting
    ==============
    - go to google font and search for Poppins
    - select and copy the links generated and paste it in the index.html file below the meta

    - In the src folder create a folder called components > then a folder called header
    - In the header folder create the following files: Header.jsx and Header.css
    
    - In the src folder create a folder called components > then a folder called hero
    - in the hero folder create the following files: Hero.jsx and Hero.css

    NB: To add the white gradient behind the text in the hero
        - add a div in App.jsx as follows and put the Header and Hero inside the div
        - create the self closing div called the white-gradient
        - in the App.css add the following:
    NB:
    To configure the slider, create a file called the commons.js file inside the utils folder
    - import it in the Properties.jsx and use it as in file

NB: Remember to install react-outside-click-handler package



NB: install react-query. axios. dayjs, react-toastify

    use it in the App.jsx as follows:
        import React, { Suspense } from "react";
        import "./App.css";
        import Entry from "./pages/Entry";
        import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
        import Layout from "./layout/Layout";
        import Listings from "./pages/Listings/Listings";
        *** import {QueryClient, QueryClientProvider} from 'react-query'

        function App() {
        const queryClient = new QueryClient()

        return (
            <div className="App">
            ***<QueryClientProvider client={queryClient}>
                <Router>
                <Suspense fallback={<div>Loading ...</div>}>
                <Routes>
                    <Route path="/" element={<Layout />}>
                    <Route index element={<Entry />} />
                    {/* Add more nested routes here as needed */}
                    <Route path="/listings" element={<Listings/>}/>
                    </Route>
                </Routes>
                </Suspense>
            </Router>
            ***</QueryClientProvider>
            
            </div>
        );
        }

        export default App;


NB: Create a folder called hooks and add the useProperties.jsx hook

    import { useQuery } from "react-query";

    // Function to fetch all properties
    async function getAllProperties() {
    // Implement your data fetching logic here
    // For example, using fetch or axios to retrieve data from an API
    }

    function useProperties() {
    // Destructure the return values from useQuery
    const { data, isError, isLoading, refetch } = useQuery(
        ["allProperties"], // Unique key for the query
        getAllProperties, // Function that fetches the data
        { refetchOnWindowFocus: false } // Configuration options
    );

    // Return the relevant data and functions
    return {
        data,      // The fetched data
        isLoading, // Boolean indicating if the query is loading
        isError,   // Boolean indicating if there was an error
        refetch,   // Function to manually refetch the data
    };
    }

    export default useProperties;


Import and use the useProperties.jsx inside the Listings.jsx

NB: in the utils folder create a file called api.js

NB: Remember to install react-spinners, lodash

NB: To add the Map Remember to install react-leaflet@4.2.1 and leaflet in the frontend
- Create the Map component and use it in the Listing.jsx
- GeoCoderMarker.jsx and use it inside the Map.jsx

NB: For Authentication I will implement Auth0
    - signup or sign in
    - go to the application page
    - create new application
    - name it
    - single page web application
    - react
    - settings
    - Allowed callback url: http://localhost:5173, http://localhost:5173/, http://localhost:5173/callback
    - Allowed Logout uri: http://localhost:5173
    - Allowed Web origin: http://localhost:5173

    Ensure API is Configured in Auth0
        Go to your Auth0 Dashboard.
        Click on Applications > APIs in the sidebar.
        Check if you have an API created with http://localhost:5000 as the Identifier (Audience).
        If not, create one:
        Name: My Local API
        Identifier: http://localhost:5000
        Signing Algorithm: Auth0


    - yarn add @auth0/auth0-react@2.0.1
    - Use the Auth0 in the main.jsx file as follows:
        NB: Copy the domain from Auth0 console: domain='dev-ccmy6um2itf0jid5.us.auth0.com'
            
            import { StrictMode } from 'react'
            import { createRoot } from 'react-dom/client'
            import './index.css'
            import App from './App.jsx'
            import {Auth0Provider} from '@auth0/auth0-react'

            createRoot(document.getElementById('root')).render(
            <StrictMode>
                <Auth0Provider
                domain='dev-ccmy6um2itf0jid5.us.auth0.com'
                clientId='lHlNWSq1xLOkWXpViqAnLCjmT0hppfqq'
                authorizationParams={
                {
                redirect_uri:"http://localhost:5173"
                }
                }
                audience="http://localhost:5000"
                scope="openid profile email"
                >
                <App />
                </Auth0Provider>
                
            </StrictMode>,
            )
    
    - yarn add @mantine/core @mantine/dates @mantine/form @emotion/react @mantine/hooks OR yarn add antd @ant-design/icons
    - Then open Header.jsx and add the following:
    - create a component called ProfileMenu.jsx and use it in the Header.jsx

SAVE USER INFORMATION IN A CONTEXT
    - create a folder in the src folder called context
    - create a file called UserDetailsContext.js in the folder created above
        - use the UserDetailsContext context in the App.jsx file
            import React, { Suspense, useState } from "react";
import "./App.css";
import Entry from "./pages/Entry";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import Layout from "./layout/Layout";
import Listings from "./pages/Listings/Listings";
import { QueryClient, QueryClientProvider } from "react-query";
import { ReactQueryDevtools } from "react-query/devtools";
import { ToastContainer } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import Listing from "./pages/listing/Listing";
import UserDetailsContext from "./context/UserDetailsContext";

function App() {
  const queryClient = new QueryClient();

 *** const [userDetails, setUserDetails] = useState({
    favourites: [],
    bookings: [],
    token: null,
  });

  return (
    <div className="App">
     *** <UserDetailsContext.Provider value={{ userDetails, setUserDetails }}>
        <QueryClientProvider client={queryClient}>
          <Router>
            <Suspense fallback={<div>Loading ...</div>}>
              <Routes>
                <Route path="/" element={<Layout />}>
                  <Route index element={<Entry />} />
                  {/* Add more nested routes here as needed */}
                  <Route path="/listings" element={<Listings />} />
                  <Route path="/listing/:id" element={<Listing />} />
                </Route>
              </Routes>
            </Suspense>
          </Router>
          <ToastContainer />
          <ReactQueryDevtools initialIsOpen={false} />
        </QueryClientProvider>
      ***</UserDetailsContext.Provider>
    </div>
  );
}

export default App;
-

- Then inside the api.js create the api call function for create user as follows:
    -


- Then open Layout.jsx and use the useContext as follows:

//Import necessary dependencies from React and other libraries
import React, { useContext, useEffect } from "react"; // React for component creation, useContext for state management, and useEffect for side effects
import "./Layout.css"; // Importing CSS styles for the Layout component
import Header from "../Components/Header/Header"; // Importing the Header component
import Footer from "../Components/Footer/Footer"; // Importing the Footer component
import { Outlet } from "react-router-dom"; // Outlet is used to render child components based on the route
import { useAuth0 } from "@auth0/auth0-react"; // Auth0 hook for authentication management
import UserDetailsContext from "../context/UserDetailsContext"; // Importing user details context for global state management
import { useMutation } from "react-query"; // Importing useMutation for API requests
import { createUser } from "../utils/api"; // Function to create a user in the backend

// Define the Layout component
function Layout() {
  // Extract authentication-related data from Auth0
  const { isAuthenticated, user } = useAuth0(); // `isAuthenticated` tells if the user is logged in, `user` contains user details

  // Access the user details context to update user-related state globally
  const { setUserDetails } = useContext(UserDetailsContext);

  // Define a mutation function to create a user in the database when they log in
  const { mutate } = useMutation({
    mutationKey: [user?.email], // The mutation is identified by the user's email
    mutationFn: () => createUser(user?.email), // Calls the API function to create a user
  });

  // useEffect runs when `isAuthenticated` changes
  useEffect(() => {
    if (isAuthenticated) {
      mutate(); // If the user is authenticated, call the mutation to register or update the user in the database
    }
  }, [isAuthenticated]); // Dependency array ensures this effect runs only when `isAuthenticated` changes

  return (
    <>
      {/* Wrapper div with styling for background color and overflow */}
      <div style={{ background: "var(--black)", overflow: "hidden" }}>
        <Header /> {/* Render the Header component */}
        <Outlet />{" "}
        {/* Render the child components based on the current route */}
        <Footer /> {/* Render the Footer component */}
      </div>
    </>
  );
}

// Export the Layout component so it can be used in other parts of the application
export default Layout;

- Then inside the config folder create a file called auth0Config.js

- update the register route with the token

BOOKING MODAL
- in the hooks folder create a file called useAuthCheck.jsx and use it in the components where you want to check authentication
 example in the: listing component for booking a visit
- Create a component called BookingModal in the components folder


Step 1: Set Up a Cloudinary Account
Go to Cloudinary and sign up.
In the Cloudinary dashboard, find your Cloud Name, API Key, and API Secret under Account Settings.
Step 2: Install Cloudinary SDK in Your Node.js Project
Run the following command in your project directory:

sh
Copy
Edit
npm install cloudinary multer multer-storage-cloudinary dotenv
cloudinary: Cloudinary SDK for image and document uploads.
multer: Middleware for handling file uploads.
multer-storage-cloudinary: Adapts Multer to store files directly in Cloudinary.
dotenv: Loads environment variables from a .env file.
Step 3: Configure Cloudinary in Your Project
Create a .env File
Add the following variables in your .env file:

env
Copy
Edit
CLOUDINARY_CLOUD_NAME=your_cloud_name
CLOUDINARY_API_KEY=your_api_key
CLOUDINARY_API_SECRET=your_api_secret
Create a cloudinary.js File
Inside a config folder, create a file named cloudinary.js:

javascript
Copy
Edit
const cloudinary = require("cloudinary").v2;
const { CloudinaryStorage } = require("multer-storage-cloudinary");
const multer = require("multer");

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

const storage = new CloudinaryStorage({
  cloudinary: cloudinary,
  params: {
    folder: "properties", // Cloudinary folder name
    allowed_formats: ["jpg", "png", "jpeg", "pdf"],
  },
});

const upload = multer({ storage });

module.exports = { cloudinary, upload };
Step 4: Modify Your API Route to Handle Uploads
Update addProperty Route to Handle Cloudinary Uploads
Modify your route handler to process file uploads before saving to the database.

Backend - Upload Images and Documents
Modify addProperty to handle image and document uploads:

javascript
Copy
Edit
const asyncHandler = require("express-async-handler");
const { upload } = require("../config/cloudinary");
const prisma = require("../prisma/client");

const addProperty = asyncHandler(async (req, res) => {
  upload.array("files", 10)(req, res, async (err) => {
    if (err) {
      return res.status(400).json({ message: "File upload failed", error: err });
    }

    if (!req.body.data) {
      return res.status(400).json({ message: "Invalid request payload." });
    }

    const {
      title,
      description,
      price,
      Region,
      address,
      city,
      country,
      gpsCode,
      propertyType,
      tenureType,
      facilities,
      userEmail,
    } = JSON.parse(req.body.data); // Parse JSON data

    if (!title || !description || !price || !address || !city || !Region || !country || !gpsCode || !propertyType || !tenureType || !userEmail) {
      return res.status(400).json({ message: "All fields are required." });
    }

    // Separate image and document URLs
    const images = req.files
      .filter((file) => file.mimetype.startsWith("image/"))
      .map((file) => file.path);

    const documentations = req.files
      .filter((file) => file.mimetype === "application/pdf")
      .map((file) => file.path);

    if (images.length < 1 || images.length > 10) {
      return res.status(400).json({ message: "You must upload between 1 and 10 images." });
    }

    if (documentations.length < 1 || documentations.length > 10) {
      return res.status(400).json({ message: "You must upload between 1 and 10 documents." });
    }

    try {
      const residency = await prisma.residency.create({
        data: {
          title,
          description,
          price,
          address,
          city,
          Region,
          country,
          gpsCode,
          propertyType,
          tenureType,
          images,
          documentations,
          facilities,
          owner: { connect: { email: userEmail } },
        },
      });

      res.status(201).json({ message: "Property created successfully", residency });
    } catch (error) {
      res.status(500).json({ message: "Failed to create property", error: error.message });
    }
  });
});

module.exports = { addProperty };
Step 5: Modify Frontend to Handle Cloudinary Uploads
Convert File List to FormData
Modify your handleSubmit function in CreateListing.js:

javascript
Copy
Edit
const handleSubmit = async () => {
  if (!isFormValid()) {
    message.error("Please fill all required fields.");
    return;
  }

  const formData = new FormData();
  formData.append("data", JSON.stringify({
    title: formData.title,
    description: formData.description,
    price: Number(formData.price),
    address: formData.address,
    gpsCode: formData.gpsCode,
    city: formData.city,
    Region: formData.Region,
    country: formData.country,
    propertyType: formData.propertyType,
    tenureType: formData.tenureType,
    facilities: formData.facilities,
    userEmail: user?.email,
  }));

  // Append images and documents
  formData.images.forEach((file) => formData.append("files", file.originFileObj));
  formData.documentations.forEach((file) => formData.append("files", file.originFileObj));

  try {
    const response = await api.post("/api/residence/addProperty", formData, {
      headers: { Authorization: `Bearer ${token}` },
    });

    message.success("Property added successfully!");
    setOpened(false);
  } catch (error) {
    message.error(`Failed to add property: ${error.message}`);
  }
};
Step 6: Test File Uploads
Start your backend server:
sh
Copy
Edit
npm run dev
Open your frontend and try uploading images/documents.
Check your Cloudinary account under the "properties" folder for uploaded files.
Final Thoughts
Security: Use Cloudinary's signed uploads for better security.
Optimizations: Utilize Cloudinary transformations for image resizing, compression, and format conversion.
Error Handling: Improve error handling to catch failed uploads.
Let me know if you need further customizations! ðŸš€



What is upload_preset?
Cloudinary Upload Preset:

An upload preset is a configuration in Cloudinary that defines default settings for file uploads.

It allows you to specify settings like:

The folder where files should be stored.

Allowed file formats.

Transformation rules (e.g., resizing, cropping).

Whether the upload is signed or unsigned.

Upload presets are created in the Cloudinary dashboard and can be reused across multiple uploads.

Unsigned Uploads:

Normally, Cloudinary requires a signature for uploads, which is generated using your api_secret.

However, if you use an unsigned upload preset, you can upload files without generating a signature. This is useful for client-side uploads where you don't want to expose your api_secret.

Where to Get the upload_preset
Create an Upload Preset in Cloudinary:

Go to your Cloudinary Dashboard.

Navigate to Settings > Upload.

Scroll down to the Upload presets section.

Click Add upload preset.

Configure the settings (e.g., folder, allowed formats, transformations).

Give the preset a name (e.g., my_unsigned_preset).

Set the Signing mode to Unsigned.

Save the preset.

Use the Upload Preset:

Once created, you can use the preset name (e.g., my_unsigned_preset) in your code.


ADD PROPERTY API ENDPOINT

Okay, I need to create an addProperty API endpoint based on the provided Prisma schema and existing code structure. Let me start by understanding the requirements.

First, looking at the Prisma schema, the Residency model has several fields. The User model relates to Residency via the ownedResidencies field. The addProperty endpoint should create a new Residency entry connected to a User via userEmail.

The existing code uses asyncHandler and Prisma. So, I'll follow that pattern. The previous functions like getAllProperties and getResidence use prisma.residency.findMany and findUnique, so for creating, I'll use prisma.residency.create.

The request body should include all necessary fields from the Residency model. Important fields are title, description, price, address, gpsCode, city, Region, country, images (array), documentations (array), facilities (JSON), userEmail, propertyType, tenureType. Also, status and propertyStatus have defaults, so they might not be required in the request.

Validation is crucial. The backend must check that images and documentations are arrays with lengths 1-10. Also, check that required fields are present. If any validation fails, return a 400 error.

Unique constraints in the Prisma schema are on address, userEmail, and gpsCode. If a duplicate is entered, Prisma will throw error code P2002, which needs to be caught and handled with a 409 Conflict response.

I should structure the endpoint as an asyncHandler function. Extract data from req.body, validate, then attempt to create the residency. Handle any errors, especially Prisma errors, and send appropriate responses.

Testing the endpoint, if the userEmail doesn't correspond to an existing User, Prisma's relation might cause an error. But the schema doesn't specify a foreign key constraint, so maybe it's allowed? Or perhaps check if the user exists first. The problem statement doesn't mention that, so perhaps proceed without checking, allowing Prisma to throw an error if the user isn't found.

Now, putting it all together. Start by destructuring the required fields from req.body. Validate each required field. Check images and documentations arrays. Then use prisma.residency.create with the data, connecting the owner via userEmail.

Handle the Prisma error for duplicates. Send success response with 201 status on success, or error messages otherwise.

I should also ensure that the facilities field is parsed as JSON. Since the facilities field is of type Json in the model, the input should be a JSON object. The req.body should send facilities as a JSON object, which Express parses automatically if the middleware is set up (like express.json()). So no extra parsing is needed here.

Finally, test cases: missing fields, invalid array lengths, duplicate entries, and successful creation. Make sure each case is handled correctly in the code.

Here's the addProperty API endpoint based on your Prisma schema and existing code structure:

javascript
Copy
// ============================================================
// Create a new property
export const addProperty = asyncHandler(async (req, res) => {
  const {
    title,
    description,
    price,
    address,
    gpsCode,
    city,
    Region,
    country,
    images,
    documentations,
    facilities,
    userEmail,
    propertyType,
    tenureType,
  } = req.body;

  // Validate required fields
  if (
    !title ||
    !description ||
    !price ||
    !address ||
    !gpsCode ||
    !city ||
    !Region ||
    !country ||
    !userEmail ||
    !propertyType ||
    !tenureType
  ) {
    return res.status(400).json({ message: "All fields are required" });
  }

  // Validate images array
  if (!Array.isArray(images) || images.length < 1 || images.length > 10) {
    return res.status(400).json({
      message: "You must upload at least 1 image and at most 10 images.",
    });
  }

  // Validate documentations array
  if (
    !Array.isArray(documentations) ||
    documentations.length < 1 ||
    documentations.length > 10
  ) {
    return res.status(400).json({
      message:
        "You must upload at least 1 document and at most 10 documents.",
    });
  }

  try {
    // Create new residency
    const residency = await prisma.residency.create({
      data: {
        title,
        description,
        price: parseInt(price),
        address,
        gpsCode,
        city,
        Region,
        country,
        images,
        documentations,
        facilities,
        propertyType,
        tenureType,
        owner: { connect: { email: userEmail } },
      },
    });

    res.status(201).json({
      success: true,
      message: "Property created successfully",
      residency,
    });
    
  } catch (error) {
    if (error.code === "P2002") {
      return res.status(409).json({
        success: false,
        message: "A property with this address and GPS code already exists for this user",
      });
    }
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      return res.status(400).json({
        success: false,
        message: "Database error",
        error: error.meta,
      });
    }
    res.status(500).json({
      success: false,
      message: "Server error",
      error: error.message,
    });
  }
});

CORRECT FIX FOR UPLOADING FILES TO FIREBASE
It looks like you've integrated Firebase Storage into your CreateListing component, but you're seeing a warning or error that getStorage is not used. This is because getStorage is used to initialize Firebase Storage, but it doesn't need to be explicitly used in your component after initialization. Instead, you're using the storage object directly, which is correct.

Let me clarify the steps and ensure everything is set up properly:

Step 1: Firebase Initialization
You've already initialized Firebase Storage in a separate file (firebase.js) and exported the storage object. This is correct. For example:

firebase.js
javascript
Copy
import { initializeApp } from "firebase/app";
import { getStorage } from "firebase/storage";

const firebaseConfig = {
  apiKey: "YOUR_API_KEY",
  authDomain: "YOUR_AUTH_DOMAIN",
  projectId: "YOUR_PROJECT_ID",
  storageBucket: "YOUR_STORAGE_BUCKET",
  messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
  appId: "YOUR_APP_ID",
};

const app = initializeApp(firebaseConfig);
const storage = getStorage(app); // Initialize Firebase Storage

export { storage };
Step 2: Using storage in Your Component
In your CreateListing component, you're importing the storage object and using it to upload files. This is correct. For example:

CreateListing.js
javascript
Copy
import { ref, uploadBytes, getDownloadURL } from "firebase/storage";
import { storage } from '../../utils/firebase'; // Adjust the path to your firebase.js file
Here, storage is used in the handleSubmit function to upload files:

javascript
Copy
const handleSubmit = async () => {
  if (!formData) {
    console.error("formData is undefined");
    return;
  }

  try {
    // Upload images to Firebase
    const imageUrls = await Promise.all(
      formData.images.map(async (image) => {
        const storageRef = ref(storage, `images/${image.name}`); // Use storage here
        await uploadBytes(storageRef, image.originFileObj); // Upload the file
        return getDownloadURL(storageRef); // Get the download URL
      })
    );

    // Upload documentations to Firebase
    const documentationUrls = await Promise.all(
      formData.documentations.map(async (doc) => {
        const storageRef = ref(storage, `documents/${doc.name}`); // Use storage here
        await uploadBytes(storageRef, doc.originFileObj); // Upload the file
        return getDownloadURL(storageRef); // Get the download URL
      })
    );

    // Construct the payload with Firebase URLs
    const payload = {
      title: formData.title,
      description: formData.description,
      price: formData.price,
      address: formData.address,
      city: formData.city,
      country: formData.country,
      gpsCode: formData.gpsCode,
      propertyType: formData.propertyType,
      tenureType: formData.tenureType,
      facilities: formData.facilities || [],
      userEmail: user?.email,
      Region: formData.Region,
      images: imageUrls, // Array of image URLs from Firebase
      documentations: documentationUrls, // Array of document URLs from Firebase
    };

    console.log("Submitting Payload:", payload); // Debugging

    // Call mutate with the JSON payload
    mutate(payload);
  } catch (error) {
    console.error("Error uploading files or submitting form:", error);
    message.error("Failed to upload files or submit form.");
  }
};
Step 3: Why getStorage is Not Used Directly
The getStorage function is used to initialize Firebase Storage in your firebase.js file. Once initialized, you don't need to use getStorage again in your component. Instead, you use the storage object directly, which is already initialized.

For example:

getStorage is used in firebase.js to initialize the storage object.

In your component, you import the storage object and use it with ref, uploadBytes, and getDownloadURL.

Step 4: Fixing the Warning
If you're seeing a warning that getStorage is not used, it's because you imported it in your component but didn't use it directly. You can safely remove the getStorage import from your component since it's already used in firebase.js.

Remove This Line:
javascript
Copy
import { getStorage, ref, uploadBytes, getDownloadURL } from "firebase/storage";
Replace With:
javascript
Copy
import { ref, uploadBytes, getDownloadURL } from "firebase/storage";
Step 5: Final Code
Hereâ€™s the updated CreateListing.js without the unnecessary getStorage import:

javascript
Copy
import { ref, uploadBytes, getDownloadURL } from "firebase/storage";
import { storage } from '../../utils/firebase'; // Adjust the path to your firebase.js file
Summary
getStorage is used in firebase.js to initialize Firebase Storage.

In your component, you only need to import and use the storage object, along with ref, uploadBytes, and getDownloadURL.

Remove the getStorage import from your component to fix the warning.

This setup ensures that Firebase Storage is properly initialized and used in your application. Let me know if you have further questions!

New chat

ADDING CRON JOB
Step 1: Install node-cron
Install the node-cron library to handle scheduled tasks:

bash
Copy
npm install node-cron
Step 2: Create a Cron Job File
Create a new file in your project, e.g., cron.js, to define the cron job logic.

bash
Copy
touch cron.js
Step 3: Write the Cron Job Logic
In the cron.js file, write the logic to check for expired bookings and completed bookings and remove them.

javascript
Copy
// cron.js
import cron from "node-cron";
import prisma from "../prisma/client"; // Adjust the import path as needed
import dayjs from "dayjs";

// Schedule a cron job to run every hour
cron.schedule("0 * * * *", async () => {
  try {
    const now = new Date();
    const currentDate = dayjs(now).format("YYYY-MM-DD");
    const currentTime = dayjs(now).format("HH:mm");

    // Find all users with expired or completed bookings
    const users = await prisma.user.findMany({
      where: {
        bookedVisit: {
          some: {
            OR: [
              {
                date: { lte: currentDate }, // Booking date is less than or equal to today
                time: { lte: currentTime }, // Booking time is less than or equal to the current time
              },
              {
                visitStatus: "completed", // Booking status is "completed"
              },
            ],
          },
        },
      },
      select: { email: true, bookedVisit: true },
    });

    // Cancel expired or completed bookings for each user
    for (const user of users) {
      const updatedBookings = user.bookedVisit.filter((visit) => {
        const bookingDateTime = dayjs(`${visit.date} ${visit.time}`);
        const currentDateTime = dayjs(`${currentDate} ${currentTime}`);

        // Keep bookings that are not expired and not completed
        return (
          bookingDateTime.isAfter(currentDateTime) &&
          visit.visitStatus !== "completed"
        );
      });

      await prisma.user.update({
        where: { email: user.email },
        data: { bookedVisit: updatedBookings },
      });
    }

    console.log("Expired and completed bookings cancelled successfully.");
  } catch (error) {
    console.error("Error cancelling expired and completed bookings:", error);
  }
});
Step 4: Start the Cron Job
In your main application file (e.g., index.js or app.js), import and start the cron job.

javascript
Copy
// index.js or app.js
import express from "express";
import "./cron"; // Import the cron job file

const app = express();

// Your existing Express setup
app.use(express.json());

// Start the server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
Step 5: Update the cancelBooking Function
Update the cancelBooking function to handle manual cancellations. This function will work alongside the cron job.

javascript
Copy
// controllers/bookingController.js
import { asyncHandler } from "../utils/asyncHandler"; // Adjust the import path as needed
import prisma from "../prisma/client"; // Adjust the import path as needed
import dayjs from "dayjs";

export const cancelBooking = asyncHandler(async (req, res) => {
  const { email } = req.body;
  const { id } = req.params;

  try {
    // Find the user and their bookings
    const user = await prisma.user.findUnique({
      where: { email: email },
      select: { bookedVisit: true },
    });

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // Get the current date and time
    const now = new Date();
    const currentDate = dayjs(now).format("YYYY-MM-DD");
    const currentTime = dayjs(now).format("HH:mm");

    // Filter out expired or completed bookings
    const updatedBookings = user.bookedVisit.filter((visit) => {
      const bookingDateTime = dayjs(`${visit.date} ${visit.time}`);
      const isExpired = bookingDateTime.isBefore(dayjs(`${currentDate} ${currentTime}`));
      const isCompleted = visit.visitStatus === "completed";

      // Keep the booking if it is not expired and not completed
      return !isExpired && !isCompleted;
    });

    // Check if the booking to be cancelled still exists after filtering
    const bookingToCancel = updatedBookings.find((visit) => visit.id === id);

    if (!bookingToCancel) {
      return res.status(404).json({ message: "Booking not found or already expired/completed" });
    }

    // Remove the booking from the updated list
    const finalBookings = updatedBookings.filter((visit) => visit.id !== id);

    // Update the user's bookings
    await prisma.user.update({
      where: { email },
      data: {
        bookedVisit: finalBookings,
      },
    });

    return res.json({ message: "Booking cancelled successfully" });
  } catch (error) {
    console.error("Error cancelling booking:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
});
Step 6: Update the Prisma Schema
Ensure your Prisma schema supports the bookedVisit field as a JSON array:

prisma
Copy
// prisma/schema.prisma
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  bookedVisit   Json?     // Array of bookings with date, time, and visitStatus
}
Step 7: Test the Implementation
Test the Cron Job:

Create a booking with a past date and time.

Wait for the cron job to run (every hour) and verify that the booking is automatically removed.

Test the cancelBooking Function:

Create an active booking.

Call the cancelBooking function and verify that the booking is successfully cancelled.

Test Completed Bookings:

Mark a booking as "completed".

Verify that the cron job removes the completed booking.

Step 8: Deploy the Application
Deploy your application to your preferred hosting platform (e.g., Vercel, Heroku, AWS). Ensure the cron job runs correctly in the production environment.

Summary
Install node-cron.

Create a cron.js file to define the cron job logic.

Start the cron job in your main application file.

Update the cancelBooking function to handle manual cancellations.

Ensure your Prisma schema supports the bookedVisit field.

Test the implementation locally and deploy it.

Step 1: Install dayjs (if not already installed)
You need the dayjs library to handle date and time comparisons. Install it if you haven't already:

bash
Copy
npm install dayjs
Step 2: Import dayjs in Your Component
At the top of your Listing.js file, import dayjs:

javascript
Copy
import dayjs from "dayjs";
Step 3: Add the removeExpiredBookings Function
Add the removeExpiredBookings function to your Listing component. This function will check for expired bookings and remove them from local storage.

Place this function inside the Listing component, just before the useEffect hooks:

javascript
Copy
function Listing() {
  const { user } = useAuth0();
  const { id } = useParams();
  const { data, isError, isLoading } = useQuery(["listing", id], () =>
    getListing(id)
  );

  // Function to check and remove expired bookings
  const removeExpiredBookings = () => {
    // Retrieve bookings from local storage
    const bookings = JSON.parse(localStorage.getItem("bookings")) || [];

    // Get the current date and time
    const now = new Date();
    const currentDateTime = dayjs(now).format("YYYY-MM-DD HH:mm");

    // Filter out expired bookings
    const updatedBookings = bookings.filter((booking) => {
      const bookingDateTime = dayjs(`${booking.date} ${booking.time}`).format("YYYY-MM-DD HH:mm");
      return dayjs(bookingDateTime).isAfter(currentDateTime); // Keep bookings that are not expired
    });

    // Save the updated bookings back to local storage
    localStorage.setItem("bookings", JSON.stringify(updatedBookings));

    console.log("Expired bookings removed from local storage");
  };

  // Rest of your component code...
}
Step 4: Run the Expiry Check Periodically
Use a useEffect hook to run the removeExpiredBookings function when the component mounts and periodically thereafter.

Add this useEffect hook inside the Listing component, just after the removeExpiredBookings function:

javascript
Copy
function Listing() {
  // ... (previous code)

  // Run the expiry check when the component mounts
  useEffect(() => {
    // Run the expiry check immediately
    removeExpiredBookings();

    // Run the expiry check every minute
    const interval = setInterval(removeExpiredBookings, 60 * 1000);

    // Cleanup the interval when the component unmounts
    return () => clearInterval(interval);
  }, []);

  // Rest of your component code...
}
Step 5: Update Local Storage When Cancelling a Booking
When a user cancels a booking, update the local storage to reflect the change. This is already handled in your removeBooking mutation, but here's the relevant code for reference:

javascript
Copy
const { mutate: removeBooking, isLoading: cancelling } = useMutation({
  mutationFn: () => cancelBooking(id, user?.email, token),
  onSuccess: () => {
    // Update the userDetails context
    setUserDetails((prev) => ({
      ...prev,
      bookings: prev.bookings.filter((booking) => booking?.id !== id), // Remove the cancelled booking
    }));

    // Update local storage
    const storedBookings = JSON.parse(localStorage.getItem("bookings")) || [];
    const updatedBookings = storedBookings.filter((booking) => booking.id !== id);
    localStorage.setItem("bookings", JSON.stringify(updatedBookings));

    toast.success("Booking cancelled successfully", {
      position: "bottom-right",
    });
  },
});
Step 6: Verify the Implementation
Add a Booking:

Add a booking with a future date and time (e.g., 2023-10-01 14:00).

Verify that the booking is stored in local storage.

Wait for Expiry:

Wait until the booking's date and time have passed.

Verify that the booking is automatically removed from local storage.

Cancel a Booking:

Cancel a booking manually.

Verify that the booking is removed from local storage.

Final Code Structure
Hereâ€™s how your Listing component should look after adding the expiry check functionality:

javascript
Copy
import React, { useContext, useEffect, useState } from "react";
import "./Listing.css";
import { useMutation, useQuery } from "react-query";
import { useParams } from "react-router-dom";
import { cancelBooking, fetchUserDetails, getListing, bookVisit } from "../../utils/api";
import { PuffLoader } from "react-spinners";
import { AiFillHeart } from "react-icons/ai";
import { FaBed, FaCar, FaCookie, FaShower } from "react-icons/fa";
import { MdAddLocation, MdMap } from "react-icons/md";
import PropertyImages from "../../Components/PropertyImages/PropertyImages";
import { Swiper, SwiperSlide, useSwiper } from "swiper/react";
import "swiper/css";
import { sliderSettings } from "../../utils/common";
import Map from "../../Components/map/Map";
import useAuthCheck from "../../hooks/useAuthCheck";
import { useAuth0 } from "@auth0/auth0-react";
import BookingModal from "../../Components/BookingModal/BookingModal";
import UserDetailsContext from "../../context/UserDetailsContext";
import { Button } from "antd";
import { toast } from "react-toastify";
import LikeButton from "../../Components/LikeButton/LikeButton.";
import { FaEdit } from "react-icons/fa";
import EditListing from "../../Components/EditListing/EditListing";
import dayjs from "dayjs";

function Listing() {
  const { user } = useAuth0();
  const { id } = useParams();
  const { data, isError, isLoading } = useQuery(["listing", id], () =>
    getListing(id)
  );

  // Function to check and remove expired bookings
  const removeExpiredBookings = () => {
    const bookings = JSON.parse(localStorage.getItem("bookings")) || [];
    const now = new Date();
    const currentDateTime = dayjs(now).format("YYYY-MM-DD HH:mm");

    const updatedBookings = bookings.filter((booking) => {
      const bookingDateTime = dayjs(`${booking.date} ${booking.time}`).format("YYYY-MM-DD HH:mm");
      return dayjs(bookingDateTime).isAfter(currentDateTime); // Keep bookings that are not expired
    });

    localStorage.setItem("bookings", JSON.stringify(updatedBookings));
    console.log("Expired bookings removed from local storage");
  };

  // Run the expiry check when the component mounts
  useEffect(() => {
    removeExpiredBookings(); // Run immediately
    const interval = setInterval(removeExpiredBookings, 60 * 1000); // Run every minute
    return () => clearInterval(interval); // Cleanup interval
  }, []);

  // Rest of your component code...
}

export default Listing;
Summary of Steps
Install dayjs (if not already installed).

Import dayjs in your Listing component.

Add the removeExpiredBookings function to check and remove expired bookings.

Use useEffect to run the expiry check periodically.

Update local storage when cancelling a booking.


ADD EMAIL.js

To replace the mailto: functionality and avoid using Outlook, you can integrate a contact form modal into your Header.jsx. This modal will allow users to submit their contact information, and you can use a backend service or an email API (like EmailJS) to send the email.

Hereâ€™s how you can update your Header.jsx and add a new ContactModal.jsx:

Step 1: Create a ContactModal.jsx
Create a new file ContactModal.jsx:

jsx
Copy
import React, { useState } from "react";
import "./ContactModal.css";

const ContactModal = ({ isOpen, onClose }) => {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    message: "",
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    // Replace these with your EmailJS credentials
    const serviceID = "YOUR_SERVICE_ID";
    const templateID = "YOUR_TEMPLATE_ID";
    const userID = "YOUR_USER_ID";

    try {
      // Send the email using EmailJS
      await emailjs.send(serviceID, templateID, formData, userID);
      alert("Thank you for contacting us! We'll get back to you soon.");
      onClose(); // Close the modal after submission
    } catch (error) {
      console.error("Failed to send email:", error);
      alert("Failed to send the message. Please try again later.");
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        <h2>Contact Us</h2>
        <form onSubmit={handleSubmit}>
          <div className="form-group">
            <label htmlFor="name">Name</label>
            <input
              type="text"
              id="name"
              name="name"
              value={formData.name}
              onChange={handleChange}
              required
            />
          </div>
          <div className="form-group">
            <label htmlFor="email">Email</label>
            <input
              type="email"
              id="email"
              name="email"
              value={formData.email}
              onChange={handleChange}
              required
            />
          </div>
          <div className="form-group">
            <label htmlFor="message">Message</label>
            <textarea
              id="message"
              name="message"
              value={formData.message}
              onChange={handleChange}
              required
            />
          </div>
          <button type="submit" className="submit-button">
            Send
          </button>
        </form>
      </div>
    </div>
  );
};

export default ContactModal;
Step 2: Add CSS for the Modal
Create a new file ContactModal.css:

css
Copy
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  padding: 20px;
  border-radius: 8px;
  width: 100%;
  max-width: 500px;
  position: relative;
}

.close-button {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
}

.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
}

.form-group input,
.form-group textarea {
  width: 100%;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.submit-button {
  background-color: #007bff;
  color: white;
  padding: 10px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.submit-button:hover {
  background-color: #0056b3;
}
Step 3: Update Header.jsx
Update your Header.jsx to include the ContactModal and handle the contact button click:

jsx
Copy
import React, { useState } from "react";
import "./Header.css";
import logo from "/logowhite.png";
import { BiMenuAltRight } from "react-icons/bi";
import OutsideClickHandler from "react-outside-click-handler";
import { Link, NavLink } from "react-router-dom";
import { useAuth0 } from "@auth0/auth0-react";
import ProfileMenu from "../ProfileMenu/ProfileMenu";
import CreateListing from "../CreateListing/CreateListing";
import useAuthCheck from "../../hooks/useAuthCheck";
import { toast } from "react-toastify";
import ContactModal from "./ContactModal"; // Import the ContactModal

function Header() {
  const [menuOpened, setMenuOpened] = useState(false);
  const [modalOpened, setModalOpened] = useState(false);
  const [contactModalOpened, setContactModalOpened] = useState(false); // State for contact modal
  const { validateLogin } = useAuthCheck();
  const { loginWithRedirect, isAuthenticated, user, logout } = useAuth0();

  // Function to handle menu styles for mobile view
  const getMenuStyles = (menuOpened) => {
    if (document.documentElement.clientWidth <= 800) {
      return { right: !menuOpened && "-100%" };
    }
  };

  // Function to handle create listing
  const handleCreateListing = () => {
    if (!validateLogin()) {
      toast.error("You must log in to create a listing.");
      setModalOpened(false);
    } else {
      setModalOpened(true);
    }
  };

  return (
    <section className="h-wrapper">
      <div className="h-container flexCenter innerWidth paddings">
        {/* Logo */}
        <Link to="/">
          <img src={logo} alt="logo" width={80} height={60} />
        </Link>

        {/* Menu */}
        <OutsideClickHandler onOutsideClick={() => setMenuOpened(false)}>
          <div className="flexCenter h-menu" style={getMenuStyles(menuOpened)}>
            {/* Listings Link */}
            <NavLink
              to="/listings"
              onClick={() => setMenuOpened(false)}
              style={{ fontWeight: "600" }}
            >
              Listings
            </NavLink>

            {/* Contact Link */}
            <a
              href="#"
              onClick={(e) => {
                e.preventDefault();
                setContactModalOpened(true); // Open the contact modal
                setMenuOpened(false);
              }}
              style={{ fontWeight: "600" }}
            >
              Contact
            </a>

            {/* Create Listing Button */}
            <div
              className="create-listing-btn"
              onClick={handleCreateListing}
              style={{
                cursor: "pointer",
                backgroundColor: "green",
                color: "white",
                padding: "8px 15px",
                borderRadius: "5px",
              }}
            >
              Add Property
            </div>
            <CreateListing opened={modalOpened} setOpened={setModalOpened} />

            {/* Login/Profile Menu */}
            {!isAuthenticated ? (
              <button className="button" onClick={loginWithRedirect}>
                Login
              </button>
            ) : (
              <ProfileMenu user={user} logout={logout} />
            )}
          </div>
        </OutsideClickHandler>

        {/* Mobile Menu Icon */}
        <div
          className="menu-icon"
          onClick={() => setMenuOpened((prev) => !prev)}
        >
          <BiMenuAltRight size={30} />
        </div>
      </div>

      {/* Contact Modal */}
      <ContactModal
        isOpen={contactModalOpened}
        onClose={() => setContactModalOpened(false)}
      />
    </section>
  );
}

export default Header;
Step 4: Set Up EmailJS
Sign up for EmailJS: Go to EmailJS and create an account.

Create a Service: Connect your email service (e.g., Gmail) to EmailJS.

Create a Template: Create an email template in EmailJS. Use placeholders like {{name}}, {{email}}, and {{message}} to dynamically insert form data.

Get Your Credentials: Copy your Service ID, Template ID, and User ID from the EmailJS dashboard and replace the placeholders in the ContactModal.jsx code.

Step 5: Test the Form
Click the "Contact" link in the header to open the modal.

Fill out the form and submit it.

Check your email inbox (the one connected to EmailJS) to confirm that the email was sent successfully.

Conclusion
By integrating a contact form modal and using EmailJS, you can provide a professional way for users to contact you without relying on Outlook or mailto:. This approach is more user-friendly and customizable.


Configuring EmailJS is straightforward. Below is a step-by-step guide to set up EmailJS and integrate it into your React application.

Step 1: Sign Up for EmailJS
Go to EmailJS.

Sign up for a free account.

Verify your email address.

Step 2: Connect Your Email Service
After logging in, go to the Email Services section.

Click Add New Service.

Choose your email service provider (e.g., Gmail, Outlook, etc.).

Follow the instructions to connect your email account.

Step 3: Create an Email Template
Go to the Email Templates section.

Click Create New Template.

Give your template a name (e.g., "Contact Form").

In the template editor, design your email using placeholders for dynamic data. For example:

plaintext
Copy
Subject: New Contact Form Submission

Name: {{name}}
Email: {{email}}
Message: {{message}}
{{name}}, {{email}}, and {{message}} are placeholders that will be replaced with the form data.

Save the template.

Step 4: Get Your Credentials
Go to the Integration section.

Copy the following credentials:

Service ID

Template ID

User ID

Step 5: Install EmailJS in Your React Project
Install the EmailJS SDK:

bash
Copy
npm install emailjs-com
Import EmailJS in your ContactModal.jsx:

javascript
Copy
import emailjs from "emailjs-com";
Step 6: Configure EmailJS in ContactModal.jsx
Update the handleSubmit function in ContactModal.jsx to use EmailJS:

javascript
Copy
const handleSubmit = async (e) => {
  e.preventDefault();

  // Replace these with your EmailJS credentials
  const serviceID = "YOUR_SERVICE_ID";
  const templateID = "YOUR_TEMPLATE_ID";
  const userID = "YOUR_USER_ID";

  try {
    // Send the email using EmailJS
    await emailjs.send(serviceID, templateID, formData, userID);
    alert("Thank you for contacting us! We'll get back to you soon.");
    onClose(); // Close the modal after submission
  } catch (error) {
    console.error("Failed to send email:", error);
    alert("Failed to send the message. Please try again later.");
  }
};
Step 7: Test the Integration
Open your React application.

Click the "Contact" button to open the modal.

Fill out the form and submit it.

Check your email inbox (the one connected to EmailJS) to confirm that the email was sent successfully.

SEND EMAIL USING NODEMAILER:
Install the necessary packages for Nodemailer and body-parser (if not already installed):

bash
Copy
npm install nodemailer body-parser
Step 2: Update index.js
Modify your index.js file to include the Nodemailer setup and a new route for sending emails.

Hereâ€™s the updated index.js:

javascript
Copy
import express from "express";
import dotenv from "dotenv";
import cookieParser from "cookie-parser";
import cors from "cors";
import nodemailer from "nodemailer";
import bodyParser from "body-parser";

// Import routes
import userRoute from "./routes/userRoute.js";
import residenceRouter from "./routes/residenceRoute.js";

dotenv.config();
const PORT = process.env.PORT || 5000;

const app = express();

// Increase request body size limit
app.use(express.json({ limit: "100mb" }));
app.use(express.urlencoded({ limit: "100mb", extended: true }));
app.use(cookieParser());
app.use(cors({ origin: "http://localhost:5173", credentials: true }));
app.use(bodyParser.json()); // Add body-parser middleware

// Nodemailer transporter
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.GMAIL_USER, // Your Gmail address from .env
    pass: process.env.GMAIL_PASS, // Your Gmail app password from .env
  },
});

// Email endpoint
app.post("/api/send-email", (req, res) => {
  const { to_email, from_name, from_email, subject, message } = req.body;

  const mailOptions = {
    from: `"${from_name}" <${from_email}>`, // Sender address
    to: to_email, // Recipient address
    subject: subject, // Email subject
    text: message, // Plain text body
    html: `<p>${message}</p>`, // HTML body
  };

  transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      console.error("Error sending email:", error);
      res.status(500).json({ success: false, message: "Failed to send email" });
    } else {
      console.log("Email sent:", info.response);
      res.status(200).json({ success: true, message: "Email sent successfully" });
    }
  });
});

// API Routes
app.use("/api/user", userRoute);
app.use("/api/residence", residenceRouter);

// Start server
app.listen(PORT, () => {
  console.log("Server is listening on port " + PORT);
});
Step 3: Update .env
Add your Gmail credentials to the .env file:

plaintext
Copy
GMAIL_USER=your-email@gmail.com
GMAIL_PASS=your-app-password
Note: Replace your-email@gmail.com with your Gmail address and your-app-password with your Gmail app password.

Step 4: Update ContactModal.jsx
Update the ContactModal.jsx to send the form data to the new /api/send-email endpoint:

jsx
Copy
import React, { useState } from "react";
import "./ContactModal.css";

const ContactModal = ({ isOpen, onClose }) => {
  const [formData, setFormData] = useState({
    to_email: "", // Recipient's email
    from_name: "", // Sender's name
    from_email: "", // Sender's email
    subject: "", // Email subject
    message: "", // Email body
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      const response = await fetch("http://localhost:5000/api/send-email", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(formData),
      });

      const result = await response.json();

      if (result.success) {
        alert("Email sent successfully!");
        onClose(); // Close the modal after submission
      } else {
        alert("Failed to send the email. Please try again later.");
      }
    } catch (error) {
      console.error("Error:", error);
      alert("Failed to send the email. Please try again later.");
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        <h2>Send Custom Email</h2>
        <form onSubmit={handleSubmit}>
          {/* Recipient's Email */}
          <div className="form-group">
            <label htmlFor="to_email">To (Recipient's Email)</label>
            <input
              type="email"
              id="to_email"
              name="to_email"
              value={formData.to_email}
              onChange={handleChange}
              required
            />
          </div>

          {/* Sender's Name */}
          <div className="form-group">
            <label htmlFor="from_name">Your Name</label>
            <input
              type="text"
              id="from_name"
              name="from_name"
              value={formData.from_name}
              onChange={handleChange}
              required
            />
          </div>

          {/* Sender's Email */}
          <div className="form-group">
            <label htmlFor="from_email">Your Email</label>
            <input
              type="email"
              id="from_email"
              name="from_email"
              value={formData.from_email}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Subject */}
          <div className="form-group">
            <label htmlFor="subject">Subject</label>
            <input
              type="text"
              id="subject"
              name="subject"
              value={formData.subject}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Body */}
          <div className="form-group">
            <label htmlFor="message">Message</label>
            <textarea
              id="message"
              name="message"
              value={formData.message}
              onChange={handleChange}
              required
            />
          </div>

          <button type="submit" className="submit-button">
            Send Email
          </button>
        </form>
      </div>
    </div>
  );
};

export default ContactModal;

=============================================
CONTACT FORM , CONTACTS WITH CHAT, VIDEO CALL AND CALL

i want to want to write a modal that will have a professional contact form. the form should be used to send email to the admin:import React, { useState } from "react";
import "./Header.css";
import { BiMenuAltRight } from "react-icons/bi";
import { getMenuStyles } from "../../utils/common";
import useHeaderColor from "../../hooks/useHeaderColor";
import OutsideClickHandler from "react-outside-click-handler";


const Header = () => {
  const [menuOpened, setMenuOpened] = useState(false);
  const headerColor = useHeaderColor();
  

  return (
    <section className="h-wrapper" style={{ background: headerColor }}>
      <div className="flexCenter innerWidth paddings h-container">
        {/* logo */}
        <img src="./logo.png" alt="logo" width={100} />

        {/* menu */}
        <OutsideClickHandler
          onOutsideClick={() => {
            setMenuOpened(false);
          }}
        >
          <div
            // ref={menuRef}
            className="flexCenter h-menu"
            style={getMenuStyles(menuOpened)}
          >
            <a href="#residencies">Residencies</a>
            <a href="#value">Our Value</a>
            <a href="#contact-us">Contact Us</a>
            <a href="#get-started">Get Started</a>
            <button className="button">
              <a href="mailto:zainkeepscode@gmail.com">Contact</a>
            </button>
          </div>
        </OutsideClickHandler>

        {/* for medium and small screens */}
        <div
          className="menu-icon"
          onClick={() => setMenuOpened((prev) => !prev)}
        >
          <BiMenuAltRight size={30} />
        </div>
      </div>
    </section>
  );
};

export default Header;
To create a modal with a professional contact form that sends an email to the admin, you can follow these steps:

Create a Modal Component: This component will contain the contact form.

Integrate the Modal with the Header: Add a button in the header to open the modal.

Handle Form Submission: Use a backend service or an email API to send the form data to the admin.

Hereâ€™s how you can implement it:

Step 1: Create a Modal Component
Create a new file ContactModal.js:

jsx
Copy
import React, { useState } from "react";
import "./ContactModal.css";

const ContactModal = ({ isOpen, onClose }) => {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    message: "",
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    // Here you would typically send the form data to your backend or an email service
    console.log("Form Data:", formData);
    alert("Thank you for contacting us!");
    onClose();
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        <h2>Contact Us</h2>
        <form onSubmit={handleSubmit}>
          <div className="form-group">
            <label htmlFor="name">Name</label>
            <input
              type="text"
              id="name"
              name="name"
              value={formData.name}
              onChange={handleChange}
              required
            />
          </div>
          <div className="form-group">
            <label htmlFor="email">Email</label>
            <input
              type="email"
              id="email"
              name="email"
              value={formData.email}
              onChange={handleChange}
              required
            />
          </div>
          <div className="form-group">
            <label htmlFor="message">Message</label>
            <textarea
              id="message"
              name="message"
              value={formData.message}
              onChange={handleChange}
              required
            />
          </div>
          <button type="submit" className="submit-button">
            Send
          </button>
        </form>
      </div>
    </div>
  );
};

export default ContactModal;
Step 2: Add CSS for the Modal
Create a new file ContactModal.css:

css
Copy
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  padding: 20px;
  border-radius: 8px;
  width: 100%;
  max-width: 500px;
  position: relative;
}

.close-button {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
}

.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
}

.form-group input,
.form-group textarea {
  width: 100%;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.submit-button {
  background-color: #007bff;
  color: white;
  padding: 10px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.submit-button:hover {
  background-color: #0056b3;
}
Step 3: Integrate the Modal with the Header
Update your Header.js to include the modal:

jsx
Copy
import React, { useState } from "react";
import "./Header.css";
import { BiMenuAltRight } from "react-icons/bi";
import { getMenuStyles } from "../../utils/common";
import useHeaderColor from "../../hooks/useHeaderColor";
import OutsideClickHandler from "react-outside-click-handler";
import ContactModal from "./ContactModal"; // Import the modal component

const Header = () => {
  const [menuOpened, setMenuOpened] = useState(false);
  const [isModalOpen, setIsModalOpen] = useState(false); // State for modal visibility
  const headerColor = useHeaderColor();

  return (
    <section className="h-wrapper" style={{ background: headerColor }}>
      <div className="flexCenter innerWidth paddings h-container">
        {/* logo */}
        <img src="./logo.png" alt="logo" width={100} />

        {/* menu */}
        <OutsideClickHandler
          onOutsideClick={() => {
            setMenuOpened(false);
          }}
        >
          <div
            className="flexCenter h-menu"
            style={getMenuStyles(menuOpened)}
          >
            <a href="#residencies">Residencies</a>
            <a href="#value">Our Value</a>
            <a href="#contact-us">Contact Us</a>
            <a href="#get-started">Get Started</a>
            <button className="button" onClick={() => setIsModalOpen(true)}>
              Contact
            </button>
          </div>
        </OutsideClickHandler>

        {/* for medium and small screens */}
        <div
          className="menu-icon"
          onClick={() => setMenuOpened((prev) => !prev)}
        >
          <BiMenuAltRight size={30} />
        </div>
      </div>

      {/* Contact Modal */}
      <ContactModal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} />
    </section>
  );
};

export default Header;
Step 4: Handle Form Submission
In the handleSubmit function within ContactModal.js, you can integrate with a backend service or an email API like EmailJS or SendGrid to send the email.

For example, using EmailJS:

Install EmailJS:

bash
Copy
npm install emailjs-com
Update handleSubmit:

jsx
Copy
import emailjs from 'emailjs-com';

const handleSubmit = async (e) => {
  e.preventDefault();

  emailjs.send('YOUR_SERVICE_ID', 'YOUR_TEMPLATE_ID', formData, 'YOUR_USER_ID')
    .then((response) => {
      console.log('SUCCESS!', response.status, response.text);
      alert("Thank you for contacting us!");
      onClose();
    }, (err) => {
      console.log('FAILED...', err);
      alert("Failed to send the message, please try again.");
    });
};
Replace YOUR_SERVICE_ID, YOUR_TEMPLATE_ID, and YOUR_USER_ID with your actual EmailJS credentials.

Conclusion
Now, when you click the "Contact" button in the header, the modal will open with a professional contact form. Upon submission, the form data can be sent to the admin via email using a service like EmailJS.

this is my Header.jsx: import React, { useState } from "react";
import "./Header.css";
import { BiMenuAltRight } from "react-icons/bi";
import { getMenuStyles } from "../../utils/common";
import useHeaderColor from "../../hooks/useHeaderColor";
import OutsideClickHandler from "react-outside-click-handler";


const Header = () => {
  const [menuOpened, setMenuOpened] = useState(false);
  const headerColor = useHeaderColor();
  

  return (
    <section className="h-wrapper" style={{ background: headerColor }}>
      <div className="flexCenter innerWidth paddings h-container">
        {/* logo */}
        <img src="./logo.png" alt="logo" width={100} />

        {/* menu */}
        <OutsideClickHandler
          onOutsideClick={() => {
            setMenuOpened(false);
          }}
        >
          <div
            // ref={menuRef}
            className="flexCenter h-menu"
            style={getMenuStyles(menuOpened)}
          >
            <a href="#residencies">Residencies</a>
            <a href="#value">Our Value</a>
            <a href="#contact-us">Contact Us</a>
            <a href="#get-started">Get Started</a>
            <button className="button">
              <a href="mailto:zainkeepscode@gmail.com">Contact</a>
            </button>
          </div>
        </OutsideClickHandler>

        {/* for medium and small screens */}
        <div
          className="menu-icon"
          onClick={() => setMenuOpened((prev) => !prev)}
        >
          <BiMenuAltRight size={30} />
        </div>
      </div>
    </section>
  );
};

export default Header;
To integrate a modal with a professional contact form into your existing Header.jsx, you can follow these steps:

Step 1: Create a Modal Component
Create a new file ContactModal.jsx:

jsx
Copy
import React, { useState } from "react";
import "./ContactModal.css";

const ContactModal = ({ isOpen, onClose }) => {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    message: "",
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    // Here you would typically send the form data to your backend or an email service
    console.log("Form Data:", formData);
    alert("Thank you for contacting us!");
    onClose();
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        <h2>Contact Us</h2>
        <form onSubmit={handleSubmit}>
          <div className="form-group">
            <label htmlFor="name">Name</label>
            <input
              type="text"
              id="name"
              name="name"
              value={formData.name}
              onChange={handleChange}
              required
            />
          </div>
          <div className="form-group">
            <label htmlFor="email">Email</label>
            <input
              type="email"
              id="email"
              name="email"
              value={formData.email}
              onChange={handleChange}
              required
            />
          </div>
          <div className="form-group">
            <label htmlFor="message">Message</label>
            <textarea
              id="message"
              name="message"
              value={formData.message}
              onChange={handleChange}
              required
            />
          </div>
          <button type="submit" className="submit-button">
            Send
          </button>
        </form>
      </div>
    </div>
  );
};

export default ContactModal;
Step 2: Add CSS for the Modal
Create a new file ContactModal.css:

css
Copy
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  padding: 20px;
  border-radius: 8px;
  width: 100%;
  max-width: 500px;
  position: relative;
}

.close-button {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
}

.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
}

.form-group input,
.form-group textarea {
  width: 100%;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.submit-button {
  background-color: #007bff;
  color: white;
  padding: 10px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.submit-button:hover {
  background-color: #0056b3;
}
Step 3: Integrate the Modal with the Header
Update your Header.jsx to include the modal:

jsx
Copy
import React, { useState } from "react";
import "./Header.css";
import { BiMenuAltRight } from "react-icons/bi";
import { getMenuStyles } from "../../utils/common";
import useHeaderColor from "../../hooks/useHeaderColor";
import OutsideClickHandler from "react-outside-click-handler";
import ContactModal from "./ContactModal"; // Import the modal component

const Header = () => {
  const [menuOpened, setMenuOpened] = useState(false);
  const [isModalOpen, setIsModalOpen] = useState(false); // State for modal visibility
  const headerColor = useHeaderColor();

  return (
    <section className="h-wrapper" style={{ background: headerColor }}>
      <div className="flexCenter innerWidth paddings h-container">
        {/* logo */}
        <img src="./logo.png" alt="logo" width={100} />

        {/* menu */}
        <OutsideClickHandler
          onOutsideClick={() => {
            setMenuOpened(false);
          }}
        >
          <div
            className="flexCenter h-menu"
            style={getMenuStyles(menuOpened)}
          >
            <a href="#residencies">Residencies</a>
            <a href="#value">Our Value</a>
            <a href="#contact-us">Contact Us</a>
            <a href="#get-started">Get Started</a>
            <button className="button" onClick={() => setIsModalOpen(true)}>
              Contact
            </button>
          </div>
        </OutsideClickHandler>

        {/* for medium and small screens */}
        <div
          className="menu-icon"
          onClick={() => setMenuOpened((prev) => !prev)}
        >
          <BiMenuAltRight size={30} />
        </div>
      </div>

      {/* Contact Modal */}
      <ContactModal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} />
    </section>
  );
};

export default Header;
Step 4: Handle Form Submission
In the handleSubmit function within ContactModal.jsx, you can integrate with a backend service or an email API like EmailJS or SendGrid to send the email.

For example, using EmailJS:

Install EmailJS:

bash
Copy
npm install emailjs-com
Update handleSubmit:

jsx
Copy
import emailjs from 'emailjs-com';

const handleSubmit = async (e) => {
  e.preventDefault();

  emailjs.send('YOUR_SERVICE_ID', 'YOUR_TEMPLATE_ID', formData, 'YOUR_USER_ID')
    .then((response) => {
      console.log('SUCCESS!', response.status, response.text);
      alert("Thank you for contacting us!");
      onClose();
    }, (err) => {
      console.log('FAILED...', err);
      alert("Failed to send the message, please try again.");
    });
};
Replace YOUR_SERVICE_ID, YOUR_TEMPLATE_ID, and YOUR_USER_ID with your actual EmailJS credentials.

Conclusion
Now, when you click the "Contact" button in the header, the modal will open with a professional contact form. Upon submission, the form data can be sent to the admin via email using a service like EmailJS.

do not use outlook
If you don't want to use Outlook or a direct mailto: link, you can use a backend service or an email API to handle the form submission. Here's how you can modify your Header.jsx and ContactModal.jsx to send emails without relying on Outlook or mailto:.

Step 1: Update Header.jsx
Replace the mailto: link with a button that opens the modal:

jsx
Copy
import React, { useState } from "react";
import "./Header.css";
import { BiMenuAltRight } from "react-icons/bi";
import { getMenuStyles } from "../../utils/common";
import useHeaderColor from "../../hooks/useHeaderColor";
import OutsideClickHandler from "react-outside-click-handler";
import ContactModal from "./ContactModal"; // Import the modal component

const Header = () => {
  const [menuOpened, setMenuOpened] = useState(false);
  const [isModalOpen, setIsModalOpen] = useState(false); // State for modal visibility
  const headerColor = useHeaderColor();

  return (
    <section className="h-wrapper" style={{ background: headerColor }}>
      <div className="flexCenter innerWidth paddings h-container">
        {/* logo */}
        <img src="./logo.png" alt="logo" width={100} />

        {/* menu */}
        <OutsideClickHandler
          onOutsideClick={() => {
            setMenuOpened(false);
          }}
        >
          <div
            className="flexCenter h-menu"
            style={getMenuStyles(menuOpened)}
          >
            <a href="#residencies">Residencies</a>
            <a href="#value">Our Value</a>
            <a href="#contact-us">Contact Us</a>
            <a href="#get-started">Get Started</a>
            <button className="button" onClick={() => setIsModalOpen(true)}>
              Contact
            </button>
          </div>
        </OutsideClickHandler>

        {/* for medium and small screens */}
        <div
          className="menu-icon"
          onClick={() => setMenuOpened((prev) => !prev)}
        >
          <BiMenuAltRight size={30} />
        </div>
      </div>

      {/* Contact Modal */}
      <ContactModal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} />
    </section>
  );
};

export default Header;
Step 2: Update ContactModal.jsx
Use an email-sending service like EmailJS or a custom backend to handle the form submission. Here's an example using EmailJS:

Install EmailJS
bash
Copy
npm install emailjs-com
Update ContactModal.jsx
jsx
Copy
import React, { useState } from "react";
import emailjs from "emailjs-com"; // Import EmailJS
import "./ContactModal.css";

const ContactModal = ({ isOpen, onClose }) => {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    message: "",
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    // Replace these with your EmailJS credentials
    const serviceID = "YOUR_SERVICE_ID";
    const templateID = "YOUR_TEMPLATE_ID";
    const userID = "YOUR_USER_ID";

    try {
      // Send the email using EmailJS
      await emailjs.send(serviceID, templateID, formData, userID);
      alert("Thank you for contacting us! We'll get back to you soon.");
      onClose(); // Close the modal after submission
    } catch (error) {
      console.error("Failed to send email:", error);
      alert("Failed to send the message. Please try again later.");
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        <h2>Contact Us</h2>
        <form onSubmit={handleSubmit}>
          <div className="form-group">
            <label htmlFor="name">Name</label>
            <input
              type="text"
              id="name"
              name="name"
              value={formData.name}
              onChange={handleChange}
              required
            />
          </div>
          <div className="form-group">
            <label htmlFor="email">Email</label>
            <input
              type="email"
              id="email"
              name="email"
              value={formData.email}
              onChange={handleChange}
              required
            />
          </div>
          <div className="form-group">
            <label htmlFor="message">Message</label>
            <textarea
              id="message"
              name="message"
              value={formData.message}
              onChange={handleChange}
              required
            />
          </div>
          <button type="submit" className="submit-button">
            Send
          </button>
        </form>
      </div>
    </div>
  );
};

export default ContactModal;
Step 3: Set Up EmailJS
Sign up for EmailJS: Go to EmailJS and create an account.

Create a Service: Connect your email service (e.g., Gmail) to EmailJS.

Create a Template: Create an email template in EmailJS. Use placeholders like {{name}}, {{email}}, and {{message}} to dynamically insert form data.

Get Your Credentials: Copy your Service ID, Template ID, and User ID from the EmailJS dashboard and replace the placeholders in the ContactModal.jsx code.

Step 4: Add CSS for the Modal
Create a new file ContactModal.css:

css
Copy
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  padding: 20px;
  border-radius: 8px;
  width: 100%;
  max-width: 500px;
  position: relative;
}

.close-button {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
}

.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
}

.form-group input,
.form-group textarea {
  width: 100%;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.submit-button {
  background-color: #007bff;
  color: white;
  padding: 10px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.submit-button:hover {
  background-color: #0056b3;
}
Step 5: Test the Form
Open the modal by clicking the "Contact" button in the header.

Fill out the form and submit it.

Check your email inbox (the one connected to EmailJS) to confirm that the email was sent successfully.

Alternative: Use a Custom Backend
If you prefer not to use EmailJS, you can set up a custom backend using Node.js, Express, and a library like nodemailer to send emails. Here's a basic example:

Backend (Node.js + Express + Nodemailer)
Install dependencies:

bash
Copy
npm install express nodemailer cors
Create a file server.js:

javascript
Copy
const express = require("express");
const cors = require("cors");
const nodemailer = require("nodemailer");

const app = express();
app.use(cors());
app.use(express.json());

const transporter = nodemailer.createTransport({
  service: "gmail", // Use your email service
  auth: {
    user: "YOUR_EMAIL@gmail.com", // Your email
    pass: "YOUR_EMAIL_PASSWORD", // Your email password or app-specific password
  },
});

app.post("/send-email", (req, res) => {
  const { name, email, message } = req.body;

  const mailOptions = {
    from: "YOUR_EMAIL@gmail.com",
    to: "ADMIN_EMAIL@gmail.com", // Admin email
    subject: "New Contact Form Submission",
    text: `Name: ${name}\nEmail: ${email}\nMessage: ${message}`,
  };

  transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      console.error("Error sending email:", error);
      res.status(500).send("Failed to send email");
    } else {
      console.log("Email sent:", info.response);
      res.status(200).send("Email sent successfully");
    }
  });
});

const PORT = 5000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
Update handleSubmit in ContactModal.jsx to send data to your backend:

javascript
Copy
const handleSubmit = async (e) => {
  e.preventDefault();

  try {
    const response = await fetch("http://localhost:5000/send-email", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(formData),
    });

    if (response.ok) {
      alert("Thank you for contacting us! We'll get back to you soon.");
      onClose();
    } else {
      alert("Failed to send the message. Please try again later.");
    }
  } catch (error) {
    console.error("Error:", error);
    alert("Failed to send the message. Please try again later.");
  }
};
Conclusion
By using EmailJS or a custom backend, you can send emails without relying on Outlook or mailto:. This approach provides a more professional and seamless user experience.

this is my Header.jsx: import React, { useState } from "react";
import "./Header.css";
import logo from "/logowhite.png";
import { BiMenuAltRight } from "react-icons/bi";
import OutsideClickHandler from "react-outside-click-handler";
import { Link, NavLink } from "react-router-dom";
import { useAuth0 } from "@auth0/auth0-react";
import ProfileMenu from "../ProfileMenu/ProfileMenu";
import CreateListing from "../CreateListing/CreateListing";
import useAuthCheck from "../../hooks/useAuthCheck";
import { toast } from "react-toastify";

function Header() {
  const [menuOpened, setMenuOpened] = useState(false);
  const [modalOpened, setModalOpened] = useState(false);
  const { validateLogin } = useAuthCheck();
  const { loginWithRedirect, isAuthenticated, user, logout } = useAuth0();

  // Function to handle menu styles for mobile view
  const getMenuStyles = (menuOpened) => {
    if (document.documentElement.clientWidth <= 800) {
      return { right: !menuOpened && "-100%" };
    }
  };

  // Function to handle create listing
  const handleCreateListing = () => {
    if (!validateLogin()) {
      toast.error("You must log in to create a listing.");
      setModalOpened(false);
    } else {
      setModalOpened(true);
    }
  };

  return (
    <section className="h-wrapper">
      <div className="h-container flexCenter innerWidth paddings">
        {/* Logo */}
        <Link to="/">
          <img src={logo} alt="logo" width={80} height={60} />
        </Link>

        {/* Menu */}
        <OutsideClickHandler onOutsideClick={() => setMenuOpened(false)}>
          <div className="flexCenter h-menu" style={getMenuStyles(menuOpened)}>
            {/* Listings Link */}
            <NavLink
              to="/listings"
              onClick={() => setMenuOpened(false)}
              style={{ fontWeight: "600" }}
            >
              Listings
            </NavLink>

            {/* Contact Link */}
            <a
              href=""
              onClick={() => setMenuOpened(false)}
              style={{ fontWeight: "600" }}
            >
              Contact
            </a>

            {/* Create Listing Button */}
            <div
              className="create-listing-btn"
              onClick={handleCreateListing}
              style={{
                cursor: "pointer",
                backgroundColor: "green",
                color: "white",
                padding: "8px 15px",
                borderRadius: "5px",
              }}
            >
              Add Property
            </div>
            <CreateListing opened={modalOpened} setOpened={setModalOpened} />

            {/* Login/Profile Menu */}
            {!isAuthenticated ? (
              <button className="button" onClick={loginWithRedirect}>
                Login
              </button>
            ) : (
              <ProfileMenu user={user} logout={logout} />
            )}
          </div>
        </OutsideClickHandler>

        {/* Mobile Menu Icon */}
        <div
          className="menu-icon"
          onClick={() => setMenuOpened((prev) => !prev)}
        >
          <BiMenuAltRight size={30} />
        </div>
      </div>
    </section>
  );
}

export default Header;
 do not use outlook
To replace the mailto: functionality and avoid using Outlook, you can integrate a contact form modal into your Header.jsx. This modal will allow users to submit their contact information, and you can use a backend service or an email API (like EmailJS) to send the email.

Hereâ€™s how you can update your Header.jsx and add a new ContactModal.jsx:

Step 1: Create a ContactModal.jsx
Create a new file ContactModal.jsx:

jsx
Copy
import React, { useState } from "react";
import "./ContactModal.css";

const ContactModal = ({ isOpen, onClose }) => {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    message: "",
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    // Replace these with your EmailJS credentials
    const serviceID = "YOUR_SERVICE_ID";
    const templateID = "YOUR_TEMPLATE_ID";
    const userID = "YOUR_USER_ID";

    try {
      // Send the email using EmailJS
      await emailjs.send(serviceID, templateID, formData, userID);
      alert("Thank you for contacting us! We'll get back to you soon.");
      onClose(); // Close the modal after submission
    } catch (error) {
      console.error("Failed to send email:", error);
      alert("Failed to send the message. Please try again later.");
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        <h2>Contact Us</h2>
        <form onSubmit={handleSubmit}>
          <div className="form-group">
            <label htmlFor="name">Name</label>
            <input
              type="text"
              id="name"
              name="name"
              value={formData.name}
              onChange={handleChange}
              required
            />
          </div>
          <div className="form-group">
            <label htmlFor="email">Email</label>
            <input
              type="email"
              id="email"
              name="email"
              value={formData.email}
              onChange={handleChange}
              required
            />
          </div>
          <div className="form-group">
            <label htmlFor="message">Message</label>
            <textarea
              id="message"
              name="message"
              value={formData.message}
              onChange={handleChange}
              required
            />
          </div>
          <button type="submit" className="submit-button">
            Send
          </button>
        </form>
      </div>
    </div>
  );
};

export default ContactModal;
Step 2: Add CSS for the Modal
Create a new file ContactModal.css:

css
Copy
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  padding: 20px;
  border-radius: 8px;
  width: 100%;
  max-width: 500px;
  position: relative;
}

.close-button {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
}

.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
}

.form-group input,
.form-group textarea {
  width: 100%;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.submit-button {
  background-color: #007bff;
  color: white;
  padding: 10px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.submit-button:hover {
  background-color: #0056b3;
}
Step 3: Update Header.jsx
Update your Header.jsx to include the ContactModal and handle the contact button click:

jsx
Copy
import React, { useState } from "react";
import "./Header.css";
import logo from "/logowhite.png";
import { BiMenuAltRight } from "react-icons/bi";
import OutsideClickHandler from "react-outside-click-handler";
import { Link, NavLink } from "react-router-dom";
import { useAuth0 } from "@auth0/auth0-react";
import ProfileMenu from "../ProfileMenu/ProfileMenu";
import CreateListing from "../CreateListing/CreateListing";
import useAuthCheck from "../../hooks/useAuthCheck";
import { toast } from "react-toastify";
import ContactModal from "./ContactModal"; // Import the ContactModal

function Header() {
  const [menuOpened, setMenuOpened] = useState(false);
  const [modalOpened, setModalOpened] = useState(false);
  const [contactModalOpened, setContactModalOpened] = useState(false); // State for contact modal
  const { validateLogin } = useAuthCheck();
  const { loginWithRedirect, isAuthenticated, user, logout } = useAuth0();

  // Function to handle menu styles for mobile view
  const getMenuStyles = (menuOpened) => {
    if (document.documentElement.clientWidth <= 800) {
      return { right: !menuOpened && "-100%" };
    }
  };

  // Function to handle create listing
  const handleCreateListing = () => {
    if (!validateLogin()) {
      toast.error("You must log in to create a listing.");
      setModalOpened(false);
    } else {
      setModalOpened(true);
    }
  };

  return (
    <section className="h-wrapper">
      <div className="h-container flexCenter innerWidth paddings">
        {/* Logo */}
        <Link to="/">
          <img src={logo} alt="logo" width={80} height={60} />
        </Link>

        {/* Menu */}
        <OutsideClickHandler onOutsideClick={() => setMenuOpened(false)}>
          <div className="flexCenter h-menu" style={getMenuStyles(menuOpened)}>
            {/* Listings Link */}
            <NavLink
              to="/listings"
              onClick={() => setMenuOpened(false)}
              style={{ fontWeight: "600" }}
            >
              Listings
            </NavLink>

            {/* Contact Link */}
            <a
              href="#"
              onClick={(e) => {
                e.preventDefault();
                setContactModalOpened(true); // Open the contact modal
                setMenuOpened(false);
              }}
              style={{ fontWeight: "600" }}
            >
              Contact
            </a>

            {/* Create Listing Button */}
            <div
              className="create-listing-btn"
              onClick={handleCreateListing}
              style={{
                cursor: "pointer",
                backgroundColor: "green",
                color: "white",
                padding: "8px 15px",
                borderRadius: "5px",
              }}
            >
              Add Property
            </div>
            <CreateListing opened={modalOpened} setOpened={setModalOpened} />

            {/* Login/Profile Menu */}
            {!isAuthenticated ? (
              <button className="button" onClick={loginWithRedirect}>
                Login
              </button>
            ) : (
              <ProfileMenu user={user} logout={logout} />
            )}
          </div>
        </OutsideClickHandler>

        {/* Mobile Menu Icon */}
        <div
          className="menu-icon"
          onClick={() => setMenuOpened((prev) => !prev)}
        >
          <BiMenuAltRight size={30} />
        </div>
      </div>

      {/* Contact Modal */}
      <ContactModal
        isOpen={contactModalOpened}
        onClose={() => setContactModalOpened(false)}
      />
    </section>
  );
}

export default Header;
Step 4: Set Up EmailJS
Sign up for EmailJS: Go to EmailJS and create an account.

Create a Service: Connect your email service (e.g., Gmail) to EmailJS.

Create a Template: Create an email template in EmailJS. Use placeholders like {{name}}, {{email}}, and {{message}} to dynamically insert form data.

Get Your Credentials: Copy your Service ID, Template ID, and User ID from the EmailJS dashboard and replace the placeholders in the ContactModal.jsx code.

Step 5: Test the Form
Click the "Contact" link in the header to open the modal.

Fill out the form and submit it.

Check your email inbox (the one connected to EmailJS) to confirm that the email was sent successfully.

Conclusion
By integrating a contact form modal and using EmailJS, you can provide a professional way for users to contact you without relying on Outlook or mailto:. This approach is more user-friendly and customizable.

how do i configure the email.js
Configuring EmailJS is straightforward. Below is a step-by-step guide to set up EmailJS and integrate it into your React application.

Step 1: Sign Up for EmailJS
Go to EmailJS.

Sign up for a free account.

Verify your email address.

Step 2: Connect Your Email Service
After logging in, go to the Email Services section.

Click Add New Service.

Choose your email service provider (e.g., Gmail, Outlook, etc.).

Follow the instructions to connect your email account.

Step 3: Create an Email Template
Go to the Email Templates section.

Click Create New Template.

Give your template a name (e.g., "Contact Form").

In the template editor, design your email using placeholders for dynamic data. For example:

plaintext
Copy
Subject: New Contact Form Submission

Name: {{name}}
Email: {{email}}
Message: {{message}}
{{name}}, {{email}}, and {{message}} are placeholders that will be replaced with the form data.

Save the template.

Step 4: Get Your Credentials
Go to the Integration section.

Copy the following credentials:

Service ID

Template ID

User ID

Step 5: Install EmailJS in Your React Project
Install the EmailJS SDK:

bash
Copy
npm install emailjs-com
Import EmailJS in your ContactModal.jsx:

javascript
Copy
import emailjs from "emailjs-com";
Step 6: Configure EmailJS in ContactModal.jsx
Update the handleSubmit function in ContactModal.jsx to use EmailJS:

javascript
Copy
const handleSubmit = async (e) => {
  e.preventDefault();

  // Replace these with your EmailJS credentials
  const serviceID = "YOUR_SERVICE_ID";
  const templateID = "YOUR_TEMPLATE_ID";
  const userID = "YOUR_USER_ID";

  try {
    // Send the email using EmailJS
    await emailjs.send(serviceID, templateID, formData, userID);
    alert("Thank you for contacting us! We'll get back to you soon.");
    onClose(); // Close the modal after submission
  } catch (error) {
    console.error("Failed to send email:", error);
    alert("Failed to send the message. Please try again later.");
  }
};
Step 7: Test the Integration
Open your React application.

Click the "Contact" button to open the modal.

Fill out the form and submit it.

Check your email inbox (the one connected to EmailJS) to confirm that the email was sent successfully.

Example: Full ContactModal.jsx
Hereâ€™s the complete ContactModal.jsx with EmailJS integration:

jsx
Copy
import React, { useState } from "react";
import emailjs from "emailjs-com"; // Import EmailJS
import "./ContactModal.css";

const ContactModal = ({ isOpen, onClose }) => {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    message: "",
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    // Replace these with your EmailJS credentials
    const serviceID = "YOUR_SERVICE_ID";
    const templateID = "YOUR_TEMPLATE_ID";
    const userID = "YOUR_USER_ID";

    try {
      // Send the email using EmailJS
      await emailjs.send(serviceID, templateID, formData, userID);
      alert("Thank you for contacting us! We'll get back to you soon.");
      onClose(); // Close the modal after submission
    } catch (error) {
      console.error("Failed to send email:", error);
      alert("Failed to send the message. Please try again later.");
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        <h2>Contact Us</h2>
        <form onSubmit={handleSubmit}>
          <div className="form-group">
            <label htmlFor="name">Name</label>
            <input
              type="text"
              id="name"
              name="name"
              value={formData.name}
              onChange={handleChange}
              required
            />
          </div>
          <div className="form-group">
            <label htmlFor="email">Email</label>
            <input
              type="email"
              id="email"
              name="email"
              value={formData.email}
              onChange={handleChange}
              required
            />
          </div>
          <div className="form-group">
            <label htmlFor="message">Message</label>
            <textarea
              id="message"
              name="message"
              value={formData.message}
              onChange={handleChange}
              required
            />
          </div>
          <button type="submit" className="submit-button">
            Send
          </button>
        </form>
      </div>
    </div>
  );
};

export default ContactModal;
Troubleshooting
Email Not Sent:

Double-check your Service ID, Template ID, and User ID.

Ensure your email service is properly connected in EmailJS.

Check the browser console for errors.

Placeholders Not Working:

Ensure the placeholders in your EmailJS template match the keys in formData (e.g., {{name}}, {{email}}, {{message}}).

CORS Issues:

EmailJS uses client-side JavaScript, so there should be no CORS issues. If you encounter problems, ensure your EmailJS credentials are correct.

Conclusion
By following these steps, you can configure EmailJS to send emails from your React application. This approach is professional, customizable, and doesnâ€™t rely on Outlook or mailto:.

I want the user to send custom email
If you want the user to send a custom email (e.g., an email with a subject, recipient, and body that the user can specify), you can modify the ContactModal.jsx to include additional fields for the recipient's email, subject, and message. Here's how you can implement it:

Step 1: Update the Form in ContactModal.jsx
Add fields for the recipient's email, subject, and message:

jsx
Copy
import React, { useState } from "react";
import emailjs from "emailjs-com"; // Import EmailJS
import "./ContactModal.css";

const ContactModal = ({ isOpen, onClose }) => {
  const [formData, setFormData] = useState({
    to_email: "", // Recipient's email
    from_name: "", // Sender's name
    from_email: "", // Sender's email
    subject: "", // Email subject
    message: "", // Email body
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    // Replace these with your EmailJS credentials
    const serviceID = "YOUR_SERVICE_ID";
    const templateID = "YOUR_TEMPLATE_ID";
    const userID = "YOUR_USER_ID";

    try {
      // Send the email using EmailJS
      await emailjs.send(serviceID, templateID, formData, userID);
      alert("Email sent successfully!");
      onClose(); // Close the modal after submission
    } catch (error) {
      console.error("Failed to send email:", error);
      alert("Failed to send the email. Please try again later.");
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        <h2>Send Custom Email</h2>
        <form onSubmit={handleSubmit}>
          {/* Recipient's Email */}
          <div className="form-group">
            <label htmlFor="to_email">To (Recipient's Email)</label>
            <input
              type="email"
              id="to_email"
              name="to_email"
              value={formData.to_email}
              onChange={handleChange}
              required
            />
          </div>

          {/* Sender's Name */}
          <div className="form-group">
            <label htmlFor="from_name">Your Name</label>
            <input
              type="text"
              id="from_name"
              name="from_name"
              value={formData.from_name}
              onChange={handleChange}
              required
            />
          </div>

          {/* Sender's Email */}
          <div className="form-group">
            <label htmlFor="from_email">Your Email</label>
            <input
              type="email"
              id="from_email"
              name="from_email"
              value={formData.from_email}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Subject */}
          <div className="form-group">
            <label htmlFor="subject">Subject</label>
            <input
              type="text"
              id="subject"
              name="subject"
              value={formData.subject}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Body */}
          <div className="form-group">
            <label htmlFor="message">Message</label>
            <textarea
              id="message"
              name="message"
              value={formData.message}
              onChange={handleChange}
              required
            />
          </div>

          <button type="submit" className="submit-button">
            Send Email
          </button>
        </form>
      </div>
    </div>
  );
};

export default ContactModal;
Step 2: Update the EmailJS Template
Go to the Email Templates section in EmailJS.

Edit your template to include the new fields:

plaintext
Copy
Subject: {{subject}}

From: {{from_name}} ({{from_email}})
To: {{to_email}}

Message:
{{message}}
Save the template.

Step 3: Test the Custom Email Form
Open your React application.

Click the "Contact" button to open the modal.

Fill out the form with the recipient's email, subject, and message.

Submit the form.

Check the recipient's email inbox to confirm that the email was sent successfully.

Example: Full ContactModal.jsx with Custom Email
Hereâ€™s the complete ContactModal.jsx with all the fields for sending a custom email:

jsx
Copy
import React, { useState } from "react";
import emailjs from "emailjs-com"; // Import EmailJS
import "./ContactModal.css";

const ContactModal = ({ isOpen, onClose }) => {
  const [formData, setFormData] = useState({
    to_email: "", // Recipient's email
    from_name: "", // Sender's name
    from_email: "", // Sender's email
    subject: "", // Email subject
    message: "", // Email body
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    // Replace these with your EmailJS credentials
    const serviceID = "YOUR_SERVICE_ID";
    const templateID = "YOUR_TEMPLATE_ID";
    const userID = "YOUR_USER_ID";

    try {
      // Send the email using EmailJS
      await emailjs.send(serviceID, templateID, formData, userID);
      alert("Email sent successfully!");
      onClose(); // Close the modal after submission
    } catch (error) {
      console.error("Failed to send email:", error);
      alert("Failed to send the email. Please try again later.");
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        <h2>Send Custom Email</h2>
        <form onSubmit={handleSubmit}>
          {/* Recipient's Email */}
          <div className="form-group">
            <label htmlFor="to_email">To (Recipient's Email)</label>
            <input
              type="email"
              id="to_email"
              name="to_email"
              value={formData.to_email}
              onChange={handleChange}
              required
            />
          </div>

          {/* Sender's Name */}
          <div className="form-group">
            <label htmlFor="from_name">Your Name</label>
            <input
              type="text"
              id="from_name"
              name="from_name"
              value={formData.from_name}
              onChange={handleChange}
              required
            />
          </div>

          {/* Sender's Email */}
          <div className="form-group">
            <label htmlFor="from_email">Your Email</label>
            <input
              type="email"
              id="from_email"
              name="from_email"
              value={formData.from_email}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Subject */}
          <div className="form-group">
            <label htmlFor="subject">Subject</label>
            <input
              type="text"
              id="subject"
              name="subject"
              value={formData.subject}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Body */}
          <div className="form-group">
            <label htmlFor="message">Message</label>
            <textarea
              id="message"
              name="message"
              value={formData.message}
              onChange={handleChange}
              required
            />
          </div>

          <button type="submit" className="submit-button">
            Send Email
          </button>
        </form>
      </div>
    </div>
  );
};

export default ContactModal;
Step 4: Update CSS (Optional)
If you want to style the form further, update ContactModal.css:

css
Copy
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  padding: 20px;
  border-radius: 8px;
  width: 100%;
  max-width: 500px;
  position: relative;
}

.close-button {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
}

.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
}

.form-group input,
.form-group textarea {
  width: 100%;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.submit-button {
  background-color: #007bff;
  color: white;
  padding: 10px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.submit-button:hover {
  background-color: #0056b3;
}
Conclusion
With this setup, users can send custom emails directly from your React application. The form allows them to specify the recipient, subject, and message, and EmailJS handles the email delivery. This approach is flexible and professional, and it doesnâ€™t rely on Outlook or mailto:.

is there any alternative to emailjs
Yes, there are several alternatives to EmailJS for sending emails from your React application. These alternatives include both third-party email APIs and self-hosted solutions. Below is a list of popular alternatives, along with their pros and cons:

1. SendGrid (by Twilio)
Description: A cloud-based email service for transactional and marketing emails.

Features:

High deliverability.

Advanced analytics.

Supports templates and dynamic content.

Pricing: Free tier available (100 emails/day), paid plans based on volume.

Website: https://sendgrid.com

How to Use:
Sign up for a SendGrid account.

Use the SendGrid API to send emails from your backend or directly from the frontend (with proper security measures).

Example: Use the @sendgrid/mail npm package.

javascript
Copy
const sgMail = require("@sendgrid/mail");
sgMail.setApiKey(process.env.SENDGRID_API_KEY);

const msg = {
  to: "recipient@example.com",
  from: "sender@example.com",
  subject: "Hello from SendGrid",
  text: "This is a test email.",
};

sgMail.send(msg).then(() => {
  console.log("Email sent");
}).catch((error) => {
  console.error(error);
});
2. Mailgun
Description: An email automation service for sending, receiving, and tracking emails.

Features:

Email validation.

Routing and parsing incoming emails.

Supports templates.

Pricing: Free tier available (10,000 emails/month), paid plans based on volume.

Website: https://www.mailgun.com

How to Use:
Sign up for a Mailgun account.

Use the Mailgun API to send emails.

Example: Use the mailgun.js npm package.

javascript
Copy
const formData = require("form-data");
const Mailgun = require("mailgun.js");
const mailgun = new Mailgun(formData);

const mg = mailgun.client({ username: "api", key: process.env.MAILGUN_API_KEY });

mg.messages.create("yourdomain.com", {
  from: "sender@example.com",
  to: ["recipient@example.com"],
  subject: "Hello from Mailgun",
  text: "This is a test email.",
}).then((msg) => {
  console.log(msg); // Logs response data
}).catch((err) => {
  console.error(err); // Logs any error
});
3. Amazon SES (Simple Email Service)
Description: A cost-effective email service for sending transactional and marketing emails.

Features:

High deliverability.

Integrates with AWS services.

Pay-as-you-go pricing.

Pricing: Free tier available (62,000 emails/month for the first year), then $0.10 per 1,000 emails.

Website: https://aws.amazon.com/ses

How to Use:
Sign up for AWS and enable SES.

Use the AWS SDK to send emails.

Example: Use the aws-sdk npm package.

javascript
Copy
const AWS = require("aws-sdk");
AWS.config.update({ region: "us-east-1" });

const ses = new AWS.SES({ apiVersion: "2010-12-01" });

const params = {
  Destination: {
    ToAddresses: ["recipient@example.com"],
  },
  Message: {
    Body: {
      Text: { Data: "This is a test email." },
    },
    Subject: { Data: "Hello from Amazon SES" },
  },
  Source: "sender@example.com",
};

ses.sendEmail(params).promise().then(() => {
  console.log("Email sent");
}).catch((err) => {
  console.error(err);
});
4. Postmark
Description: A transactional email service with a focus on simplicity and reliability.

Features:

High deliverability.

Real-time analytics.

Supports templates.

Pricing: Free trial available, then $10 for 10,000 emails.

Website: https://postmarkapp.com

How to Use:
Sign up for Postmark.

Use the Postmark API to send emails.

Example: Use the postmark npm package.

javascript
Copy
const postmark = require("postmark");

const client = new postmark.ServerClient(process.env.POSTMARK_API_KEY);

client.sendEmail({
  From: "sender@example.com",
  To: "recipient@example.com",
  Subject: "Hello from Postmark",
  TextBody: "This is a test email.",
}).then((response) => {
  console.log("Email sent:", response);
}).catch((error) => {
  console.error("Error sending email:", error);
});
5. Nodemailer (Self-Hosted)
Description: A Node.js module for sending emails. You can use it with your own SMTP server or third-party services like Gmail, Outlook, etc.

Features:

Flexible and customizable.

Supports attachments, HTML emails, and templates.

Pricing: Free (but you need to provide your own SMTP server or use a third-party service).

Website: https://nodemailer.com

How to Use:
Install Nodemailer:

bash
Copy
npm install nodemailer
Configure Nodemailer to send emails:

javascript
Copy
const nodemailer = require("nodemailer");

const transporter = nodemailer.createTransport({
  service: "gmail", // Use your email service
  auth: {
    user: "your-email@gmail.com",
    pass: "your-email-password",
  },
});

const mailOptions = {
  from: "your-email@gmail.com",
  to: "recipient@example.com",
  subject: "Hello from Nodemailer",
  text: "This is a test email.",
};

transporter.sendMail(mailOptions, (error, info) => {
  if (error) {
    console.error("Error sending email:", error);
  } else {
    console.log("Email sent:", info.response);
  }
});
6. Brevo (formerly Sendinblue)
Description: An all-in-one marketing platform with email, SMS, and chat features.

Features:

Transactional and marketing emails.

Free tier with 300 emails/day.

Drag-and-drop email builder.

Pricing: Free tier available, paid plans based on volume.

Website: https://www.brevo.com

How to Use:
Sign up for Brevo.

Use the Brevo API to send emails.

Example: Use the sib-api-v3-sdk npm package.

javascript
Copy
const SibApiV3Sdk = require("sib-api-v3-sdk");
const defaultClient = SibApiV3Sdk.ApiClient.instance;

const apiKey = defaultClient.authentications["api-key"];
apiKey.apiKey = process.env.BREVO_API_KEY;

const apiInstance = new SibApiV3Sdk.TransactionalEmailsApi();

const sendSmtpEmail = new SibApiV3Sdk.SendSmtpEmail();
sendSmtpEmail.subject = "Hello from Brevo";
sendSmtpEmail.sender = { email: "sender@example.com", name: "Sender Name" };
sendSmtpEmail.to = [{ email: "recipient@example.com", name: "Recipient Name" }];
sendSmtpEmail.textContent = "This is a test email.";

apiInstance.sendTransacEmail(sendSmtpEmail).then((data) => {
  console.log("Email sent:", data);
}).catch((error) => {
  console.error("Error sending email:", error);
});
7. SMTP.js
Description: A lightweight library for sending emails directly from the browser using SMTP.

Features:

No backend required.

Easy to set up.

Pricing: Free (but you need to provide your own SMTP credentials).

Website: https://smtpjs.com

How to Use:
Include SMTP.js in your HTML:

html
Copy
<script src="https://smtpjs.com/v3/smtp.js"></script>
Run HTML
Send an email:

javascript
Copy
Email.send({
  Host: "smtp.yourdomain.com",
  Username: "your-email@example.com",
  Password: "your-email-password",
  To: "recipient@example.com",
  From: "your-email@example.com",
  Subject: "Hello from SMTP.js",
  Body: "This is a test email.",
}).then((message) => {
  console.log("Email sent:", message);
});
Conclusion
Each alternative has its own strengths and weaknesses. If you want a quick and easy solution, EmailJS or SMTP.js are great choices. For scalability and advanced features, consider SendGrid, Mailgun, or Amazon SES. If you prefer a self-hosted solution, Nodemailer is a flexible option.

Choose the one that best fits your project's requirements!

for my case i want to use nodemailer with gmail: i need the step by step
Using Nodemailer with Gmail is a great choice for sending emails from your application. Below is a step-by-step guide to set up Nodemailer with Gmail in your Node.js backend.

Step 1: Set Up a Node.js Project
Create a new project folder:

bash
Copy
mkdir nodemailer-gmail
cd nodemailer-gmail
Initialize a Node.js project:

bash
Copy
npm init -y
Install Nodemailer:

bash
Copy
npm install nodemailer
Install Express (optional, for creating an API endpoint):

bash
Copy
npm install express
Step 2: Configure Gmail
Use a Gmail Account:

You need a Gmail account to send emails.

If you donâ€™t want to use your personal Gmail account, create a new one for your application.

Enable Less Secure Apps (if using a regular Gmail account):

Go to Google Account Settings.

Navigate to Security > Less secure app access.

Turn on Allow less secure apps.

Note: Google may block access if it detects unusual activity. For production, use OAuth2 (explained later).

Generate an App Password (recommended for better security):

Go to Google Account Settings.

Navigate to Security > App passwords.

Generate a new app password and save it.

Step 3: Create the Nodemailer Setup
Create a file index.js:

bash
Copy
touch index.js
Add the following code to index.js:

javascript
Copy
const nodemailer = require("nodemailer");

// Step 1: Create a transporter
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: "your-email@gmail.com", // Your Gmail address
    pass: "your-app-password", // Your Gmail password or app password
  },
});

// Step 2: Define email options
const mailOptions = {
  from: "your-email@gmail.com", // Sender address
  to: "recipient@example.com", // Recipient address
  subject: "Hello from Nodemailer", // Email subject
  text: "This is a test email sent using Nodemailer.", // Plain text body
  html: "<h1>Hello from Nodemailer</h1><p>This is a test email sent using Nodemailer.</p>", // HTML body
};

// Step 3: Send the email
transporter.sendMail(mailOptions, (error, info) => {
  if (error) {
    console.error("Error sending email:", error);
  } else {
    console.log("Email sent:", info.response);
  }
});
Replace the placeholders:

Replace your-email@gmail.com with your Gmail address.

Replace your-app-password with your Gmail password or app password.

Replace recipient@example.com with the recipient's email address.

Step 4: Test the Setup
Run the script:

bash
Copy
node index.js
Check the recipient's inbox:

The recipient should receive the email.

If the email is not delivered, check the console for errors.

Step 5: Use OAuth2 for Better Security (Optional)
Using OAuth2 is recommended for production to avoid issues with less secure apps and app passwords.

Set up a Google Cloud Project:

Go to the Google Cloud Console.

Create a new project.

Enable the **G

i already have the project: this is my Header.jsx: import React, { useState } from "react";
import "./Header.css";
import logo from "/logowhite.png";
import { BiMenuAltRight } from "react-icons/bi";
import OutsideClickHandler from "react-outside-click-handler";
import { Link, NavLink } from "react-router-dom";
import { useAuth0 } from "@auth0/auth0-react";
import ProfileMenu from "../ProfileMenu/ProfileMenu";
import CreateListing from "../CreateListing/CreateListing";
import useAuthCheck from "../../hooks/useAuthCheck";
import { toast } from "react-toastify";
import ContactModal from "../ContactModal/ContactModal";


function Header() {
  const [menuOpened, setMenuOpened] = useState(false);
  const [modalOpened, setModalOpened] = useState(false);
  const [contactModalOpened, setContactModalOpened] = useState(false); // State for contact modal
  const { validateLogin } = useAuthCheck();
  const { loginWithRedirect, isAuthenticated, user, logout } = useAuth0();

  // Function to handle menu styles for mobile view
  const getMenuStyles = (menuOpened) => {
    if (document.documentElement.clientWidth <= 800) {
      return { right: !menuOpened && "-100%" };
    }
  };

  // Function to handle create listing
  const handleCreateListing = () => {
    if (!validateLogin()) {
      toast.error("You must log in to create a listing.");
      setModalOpened(false);
    } else {
      setModalOpened(true);
    }
  };

  return (
    <section className="h-wrapper">
      <div className="h-container flexCenter innerWidth paddings">
        {/* Logo */}
        <Link to="/">
          <img src={logo} alt="logo" width={80} height={60} />
        </Link>

        {/* Menu */}
        <OutsideClickHandler onOutsideClick={() => setMenuOpened(false)}>
          <div className="flexCenter h-menu" style={getMenuStyles(menuOpened)}>
            {/* Listings Link */}
            <NavLink
              to="/listings"
              onClick={() => setMenuOpened(false)}
              style={{ fontWeight: "600" }}
            >
              Listings
            </NavLink>

            {/* Contact Link */}
            <a
              href="#"
              onClick={(e) => {
                e.preventDefault();
                setContactModalOpened(true); // Open the contact modal
                setMenuOpened(false);
              }}
              style={{ fontWeight: "600" }}
            >
              Contact
            </a>

            {/* Create Listing Button */}
            <div
              className="create-listing-btn"
              onClick={handleCreateListing}
              style={{
                cursor: "pointer",
                backgroundColor: "green",
                color: "white",
                padding: "8px 15px",
                borderRadius: "5px",
              }}
            >
              Add Property
            </div>
            <CreateListing opened={modalOpened} setOpened={setModalOpened} />

            {/* Login/Profile Menu */}
            {!isAuthenticated ? (
              <button className="button" onClick={loginWithRedirect}>
                Login
              </button>
            ) : (
              <ProfileMenu user={user} logout={logout} />
            )}
          </div>
        </OutsideClickHandler>

        {/* Mobile Menu Icon */}
        <div
          className="menu-icon"
          onClick={() => setMenuOpened((prev) => !prev)}
        >
          <BiMenuAltRight size={30} />
        </div>
      </div>

      {/* Contact Modal */}
      <ContactModal
        isOpen={contactModalOpened}
        onClose={() => setContactModalOpened(false)}
      />
    </section>
  );
}

export default Header;
To integrate Nodemailer with Gmail into your existing project, you need to set up a backend endpoint to handle the email sending. Here's a step-by-step guide to achieve this:

Step 1: Set Up the Backend (Node.js + Express + Nodemailer)
Install dependencies:
In your project's root directory, install the required packages:

bash
Copy
npm install express nodemailer cors body-parser
Create a backend folder:
Create a folder named backend in your project root:

bash
Copy
mkdir backend
cd backend
Create a file server.js:
Inside the backend folder, create a file named server.js and add the following code:

javascript
Copy
const express = require("express");
const nodemailer = require("nodemailer");
const cors = require("cors");
const bodyParser = require("body-parser");

const app = express();
const PORT = 5000;

// Middleware
app.use(cors());
app.use(bodyParser.json());

// Nodemailer transporter
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: "your-email@gmail.com", // Replace with your Gmail address
    pass: "your-app-password", // Replace with your Gmail app password
  },
});

// Email endpoint
app.post("/send-email", (req, res) => {
  const { to_email, from_name, from_email, subject, message } = req.body;

  const mailOptions = {
    from: `"${from_name}" <${from_email}>`, // Sender address
    to: to_email, // Recipient address
    subject: subject, // Email subject
    text: message, // Plain text body
    html: `<p>${message}</p>`, // HTML body
  };

  transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      console.error("Error sending email:", error);
      res.status(500).json({ success: false, message: "Failed to send email" });
    } else {
      console.log("Email sent:", info.response);
      res.status(200).json({ success: true, message: "Email sent successfully" });
    }
  });
});

// Start the server
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
Replace placeholders:

Replace your-email@gmail.com with your Gmail address.

Replace your-app-password with your Gmail app password.

Run the backend server:
Start the backend server:

bash
Copy
node server.js
The server will run on http://localhost:5000.

Step 2: Update the ContactModal.jsx
Update the ContactModal.jsx to send the form data to the backend:

jsx
Copy
import React, { useState } from "react";
import "./ContactModal.css";

const ContactModal = ({ isOpen, onClose }) => {
  const [formData, setFormData] = useState({
    to_email: "", // Recipient's email
    from_name: "", // Sender's name
    from_email: "", // Sender's email
    subject: "", // Email subject
    message: "", // Email body
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      const response = await fetch("http://localhost:5000/send-email", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(formData),
      });

      const result = await response.json();

      if (result.success) {
        alert("Email sent successfully!");
        onClose(); // Close the modal after submission
      } else {
        alert("Failed to send the email. Please try again later.");
      }
    } catch (error) {
      console.error("Error:", error);
      alert("Failed to send the email. Please try again later.");
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        <h2>Send Custom Email</h2>
        <form onSubmit={handleSubmit}>
          {/* Recipient's Email */}
          <div className="form-group">
            <label htmlFor="to_email">To (Recipient's Email)</label>
            <input
              type="email"
              id="to_email"
              name="to_email"
              value={formData.to_email}
              onChange={handleChange}
              required
            />
          </div>

          {/* Sender's Name */}
          <div className="form-group">
            <label htmlFor="from_name">Your Name</label>
            <input
              type="text"
              id="from_name"
              name="from_name"
              value={formData.from_name}
              onChange={handleChange}
              required
            />
          </div>

          {/* Sender's Email */}
          <div className="form-group">
            <label htmlFor="from_email">Your Email</label>
            <input
              type="email"
              id="from_email"
              name="from_email"
              value={formData.from_email}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Subject */}
          <div className="form-group">
            <label htmlFor="subject">Subject</label>
            <input
              type="text"
              id="subject"
              name="subject"
              value={formData.subject}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Body */}
          <div className="form-group">
            <label htmlFor="message">Message</label>
            <textarea
              id="message"
              name="message"
              value={formData.message}
              onChange={handleChange}
              required
            />
          </div>

          <button type="submit" className="submit-button">
            Send Email
          </button>
        </form>
      </div>
    </div>
  );
};

export default ContactModal;
Step 3: Update ContactModal.css
Add the following CSS to style the modal:

css
Copy
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  padding: 20px;
  border-radius: 8px;
  width: 100%;
  max-width: 500px;
  position: relative;
}

.close-button {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
}

.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
}

.form-group input,
.form-group textarea {
  width: 100%;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.submit-button {
  background-color: #007bff;
  color: white;
  padding: 10px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.submit-button:hover {
  background-color: #0056b3;
}
Step 4: Test the Integration
Start the backend server:

bash
Copy
node backend/server.js
Run your React app:

bash
Copy
npm start
Open the contact modal:

Click the "Contact" link in the header.

Fill out the form and submit it.

Check the recipient's inbox:

The recipient should receive the email.

Conclusion
You now have a fully functional contact form that sends emails using Nodemailer with Gmail. This setup is secure, scalable, and easy to maintain. If you want to further enhance security, consider using OAuth2 for Gmail authentication.

This is my index.js: rewrite the steps from scratch: import express from "express";
import dotenv from "dotenv";
import cookieParser from "cookie-parser";
import cors from "cors";


// Import routes
import userRoute from "./routes/userRoute.js";
import residenceRouter from "./routes/residenceRoute.js";

dotenv.config();
const PORT = process.env.PORT || 5000;

const app = express();

// Increase request body size limit
app.use(express.json({ limit: "100mb" }));
app.use(express.urlencoded({ limit: "100mb", extended: true }));
app.use(cookieParser());
app.use(cors({ origin: "http://localhost:5173", credentials: true }));

// API Routes
app.use("/api/user", userRoute);
app.use("/api/residence", residenceRouter);

// Start server
app.listen(PORT, () => {
  console.log("Server is listening on port " + PORT);
});
To integrate Nodemailer with Gmail into your existing index.js file, follow these steps from scratch:

Step 1: Install Required Dependencies
Install the necessary packages for Nodemailer and body-parser (if not already installed):

bash
Copy
npm install nodemailer body-parser
Step 2: Update index.js
Modify your index.js file to include the Nodemailer setup and a new route for sending emails.

Hereâ€™s the updated index.js:

javascript
Copy
import express from "express";
import dotenv from "dotenv";
import cookieParser from "cookie-parser";
import cors from "cors";
import nodemailer from "nodemailer";
import bodyParser from "body-parser";

// Import routes
import userRoute from "./routes/userRoute.js";
import residenceRouter from "./routes/residenceRoute.js";

dotenv.config();
const PORT = process.env.PORT || 5000;

const app = express();

// Increase request body size limit
app.use(express.json({ limit: "100mb" }));
app.use(express.urlencoded({ limit: "100mb", extended: true }));
app.use(cookieParser());
app.use(cors({ origin: "http://localhost:5173", credentials: true }));
app.use(bodyParser.json()); // Add body-parser middleware

// Nodemailer transporter
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.GMAIL_USER, // Your Gmail address from .env
    pass: process.env.GMAIL_PASS, // Your Gmail app password from .env
  },
});

// Email endpoint
app.post("/api/send-email", (req, res) => {
  const { to_email, from_name, from_email, subject, message } = req.body;

  const mailOptions = {
    from: `"${from_name}" <${from_email}>`, // Sender address
    to: to_email, // Recipient address
    subject: subject, // Email subject
    text: message, // Plain text body
    html: `<p>${message}</p>`, // HTML body
  };

  transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      console.error("Error sending email:", error);
      res.status(500).json({ success: false, message: "Failed to send email" });
    } else {
      console.log("Email sent:", info.response);
      res.status(200).json({ success: true, message: "Email sent successfully" });
    }
  });
});

// API Routes
app.use("/api/user", userRoute);
app.use("/api/residence", residenceRouter);

// Start server
app.listen(PORT, () => {
  console.log("Server is listening on port " + PORT);
});
Step 3: Update .env
Add your Gmail credentials to the .env file:

plaintext
Copy
GMAIL_USER=your-email@gmail.com
GMAIL_PASS=your-app-password
Note: Replace your-email@gmail.com with your Gmail address and your-app-password with your Gmail app password.

Step 4: Update ContactModal.jsx
Update the ContactModal.jsx to send the form data to the new /api/send-email endpoint:

jsx
Copy
import React, { useState } from "react";
import "./ContactModal.css";

const ContactModal = ({ isOpen, onClose }) => {
  const [formData, setFormData] = useState({
    to_email: "", // Recipient's email
    from_name: "", // Sender's name
    from_email: "", // Sender's email
    subject: "", // Email subject
    message: "", // Email body
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      const response = await fetch("http://localhost:5000/api/send-email", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(formData),
      });

      const result = await response.json();

      if (result.success) {
        alert("Email sent successfully!");
        onClose(); // Close the modal after submission
      } else {
        alert("Failed to send the email. Please try again later.");
      }
    } catch (error) {
      console.error("Error:", error);
      alert("Failed to send the email. Please try again later.");
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        <h2>Send Custom Email</h2>
        <form onSubmit={handleSubmit}>
          {/* Recipient's Email */}
          <div className="form-group">
            <label htmlFor="to_email">To (Recipient's Email)</label>
            <input
              type="email"
              id="to_email"
              name="to_email"
              value={formData.to_email}
              onChange={handleChange}
              required
            />
          </div>

          {/* Sender's Name */}
          <div className="form-group">
            <label htmlFor="from_name">Your Name</label>
            <input
              type="text"
              id="from_name"
              name="from_name"
              value={formData.from_name}
              onChange={handleChange}
              required
            />
          </div>

          {/* Sender's Email */}
          <div className="form-group">
            <label htmlFor="from_email">Your Email</label>
            <input
              type="email"
              id="from_email"
              name="from_email"
              value={formData.from_email}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Subject */}
          <div className="form-group">
            <label htmlFor="subject">Subject</label>
            <input
              type="text"
              id="subject"
              name="subject"
              value={formData.subject}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Body */}
          <div className="form-group">
            <label htmlFor="message">Message</label>
            <textarea
              id="message"
              name="message"
              value={formData.message}
              onChange={handleChange}
              required
            />
          </div>

          <button type="submit" className="submit-button">
            Send Email
          </button>
        </form>
      </div>
    </div>
  );
};

export default ContactModal;
Step 5: Test the Integration
Start the backend server:

bash
Copy
node index.js
Run your React app:

bash
Copy
npm start
Open the contact modal:

Click the "Contact" link in the header.

Fill out the form and submit it.

Check the recipient's inbox:

The recipient should receive the email.

Conclusion
Youâ€™ve successfully integrated Nodemailer with Gmail into your existing backend. The /api/send-email endpoint handles email sending, and the ContactModal.jsx form sends the data to this endpoint. This setup is secure, scalable, and easy to maintain. If you want to further enhance security, consider using OAuth2 for Gmail authentication.

I want the to email to be idbsch2012@gmail.com. also hide the to email:import React, { useState } from "react";
import "./ContactModal.css";

const ContactModal = ({ isOpen, onClose }) => {
  const [formData, setFormData] = useState({
    to_email: "", // Recipient's email
    from_name: "", // Sender's name
    from_email: "", // Sender's email
    subject: "", // Email subject
    message: "", // Email body
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      const response = await fetch("http://localhost:5000/api/send-email", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(formData),
      });

      const result = await response.json();

      if (result.success) {
        alert("Email sent successfully!");
        onClose(); // Close the modal after submission
      } else {
        alert("Failed to send the email. Please try again later.");
      }
    } catch (error) {
      console.error("Error:", error);
      alert("Failed to send the email. Please try again later.");
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        <h2>Send Custom Email</h2>
        <form onSubmit={handleSubmit}>
          {/* Recipient's Email */}
          <div className="form-group">
            <label htmlFor="to_email">To (Recipient's Email)</label>
            <input
              type="email"
              id="to_email"
              name="to_email"
              value={formData.to_email}
              onChange={handleChange}
              required
            />
          </div>

          {/* Sender's Name */}
          <div className="form-group">
            <label htmlFor="from_name">Your Name</label>
            <input
              type="text"
              id="from_name"
              name="from_name"
              value={formData.from_name}
              onChange={handleChange}
              required
            />
          </div>

          {/* Sender's Email */}
          <div className="form-group">
            <label htmlFor="from_email">Your Email</label>
            <input
              type="email"
              id="from_email"
              name="from_email"
              value={formData.from_email}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Subject */}
          <div className="form-group">
            <label htmlFor="subject">Subject</label>
            <input
              type="text"
              id="subject"
              name="subject"
              value={formData.subject}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Body */}
          <div className="form-group">
            <label htmlFor="message">Message</label>
            <textarea
              id="message"
              name="message"
              value={formData.message}
              onChange={handleChange}
              required
            />
          </div>

          <button type="submit" className="submit-button">
            Send Email
          </button>
        </form>
      </div>
    </div>
  );
};

export default ContactModal;
(Due to technical issues, the search service is temporarily unavailable.)

To set the recipient's email (to_email) to a fixed value (idbsch2012@gmail.com) and hide it from the user, you can make the following changes:

Remove the to_email input field from the form since it will no longer be user-editable.

Set the to_email value directly in the formData state.

Send the fixed to_email value to the backend without displaying it to the user.

Hereâ€™s the updated ContactModal.jsx:

Updated ContactModal.jsx
jsx
Copy
import React, { useState } from "react";
import "./ContactModal.css";

const ContactModal = ({ isOpen, onClose }) => {
  const [formData, setFormData] = useState({
    to_email: "idbsch2012@gmail.com", // Fixed recipient's email
    from_name: "", // Sender's name
    from_email: "", // Sender's email
    subject: "", // Email subject
    message: "", // Email body
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      const response = await fetch("http://localhost:5000/api/send-email", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(formData),
      });

      const result = await response.json();

      if (result.success) {
        alert("Email sent successfully!");
        onClose(); // Close the modal after submission
      } else {
        alert("Failed to send the email. Please try again later.");
      }
    } catch (error) {
      console.error("Error:", error);
      alert("Failed to send the email. Please try again later.");
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        <h2>Contact Us</h2>
        <form onSubmit={handleSubmit}>
          {/* Sender's Name */}
          <div className="form-group">
            <label htmlFor="from_name">Your Name</label>
            <input
              type="text"
              id="from_name"
              name="from_name"
              value={formData.from_name}
              onChange={handleChange}
              required
            />
          </div>

          {/* Sender's Email */}
          <div className="form-group">
            <label htmlFor="from_email">Your Email</label>
            <input
              type="email"
              id="from_email"
              name="from_email"
              value={formData.from_email}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Subject */}
          <div className="form-group">
            <label htmlFor="subject">Subject</label>
            <input
              type="text"
              id="subject"
              name="subject"
              value={formData.subject}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Body */}
          <div className="form-group">
            <label htmlFor="message">Message</label>
            <textarea
              id="message"
              name="message"
              value={formData.message}
              onChange={handleChange}
              required
            />
          </div>

          <button type="submit" className="submit-button">
            Send Email
          </button>
        </form>
      </div>
    </div>
  );
};

export default ContactModal;
Key Changes
Removed the to_email Input Field:

The to_email field is no longer displayed in the form since it is fixed.

Set to_email in the State:

The to_email is hardcoded to idbsch2012@gmail.com in the formData state.

Sent to_email to the Backend:

The to_email value is included in the formData object sent to the backend.

Updated Backend (index.js)
Ensure your backend is set up to handle the to_email field correctly. Hereâ€™s the relevant part of the backend code:

javascript
Copy
app.post("/api/send-email", (req, res) => {
  const { to_email, from_name, from_email, subject, message } = req.body;

  const mailOptions = {
    from: `"${from_name}" <${from_email}>`, // Sender address
    to: to_email, // Recipient address (fixed to idbsch2012@gmail.com)
    subject: subject, // Email subject
    text: message, // Plain text body
    html: `<p>${message}</p>`, // HTML body
  };

  transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      console.error("Error sending email:", error);
      res.status(500).json({ success: false, message: "Failed to send email" });
    } else {
      console.log("Email sent:", info.response);
      res.status(200).json({ success: true, message: "Email sent successfully" });
    }
  });
});
Updated .env
Ensure your .env file contains the correct Gmail credentials:

plaintext
Copy
GMAIL_USER=your-email@gmail.com
GMAIL_PASS=your-app-password
Test the Integration
Start the backend server:

bash
Copy
node index.js
Run your React app:

bash
Copy
npm start
Open the contact modal:

Click the "Contact" link in the header.

Fill out the form and submit it.

Check the recipient's inbox:

The email should be sent to idbsch2012@gmail.com.

Conclusion
By hardcoding the to_email value and removing the input field, you ensure that emails are always sent to idbsch2012@gmail.com without exposing this information to the user. This approach is clean, secure, and easy to maintain.

from email is showing as to email in the gmail: import React, { useState } from "react";
import "./ContactModal.css";
import { toast } from "react-toastify";

const ContactModal = ({ isOpen, onClose }) => {
  const [formData, setFormData] = useState({
    to_email: "idbsch2012@gmail.com", // Fixed recipient's email
    from_name: "", // Sender's name
    from_email: "", // Sender's email
    subject: "", // Email subject
    message: "", // Email body
  });
  

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    try {
      const response = await fetch("http://localhost:5000/api/send-email", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(formData),
      });

      const result = await response.json();

      if (result.success) {
        toast.success("Email sent successfully!")
        onClose(); // Close the modal after submission
      } else {
        alert("Failed to send the email. Please try again later.");
      }
    } catch (error) {
      console.error("Error:", error);
      alert("Failed to send the email. Please try again later.");
    }
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        <h2 style={{color:"black"}}>Contact Us</h2>
        <form onSubmit={handleSubmit}>
          {/* Sender's Name */}
          <div className="form-group">
            <label htmlFor="from_name">Your Name</label>
            <input
              type="text"
              id="from_name"
              name="from_name"
              value={formData.from_name}
              onChange={handleChange}
              required
              
            />
          </div>

          {/* Sender's Email */}
          <div className="form-group">
            <label htmlFor="from_email">Your Email</label>
            <input
              type="email"
              id="from_email"
              name="from_email"
              value={formData.from_email}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Subject */}
          <div className="form-group">
            <label htmlFor="subject">Subject</label>
            <input
              type="text"
              id="subject"
              name="subject"
              value={formData.subject}
              onChange={handleChange}
              required
            />
          </div>

          {/* Email Body */}
          <div className="form-group">
            <label htmlFor="message">Message</label>
            <textarea
              id="message"
              name="message"
              value={formData.message}
              onChange={handleChange}
              required
            />
          </div>

          <button type="submit" className="submit-button">
            Send Email
          </button>
        </form>
      </div>
    </div>
  );
};

export default ContactModal; import express from "express";
import dotenv from "dotenv";
import cookieParser from "cookie-parser";
import cors from "cors";
import nodemailer from "nodemailer";
import bodyParser from "body-parser";

// Import routes
import userRoute from "./routes/userRoute.js";
import residenceRouter from "./routes/residenceRoute.js";

dotenv.config();
const PORT = process.env.PORT || 5000;

const app = express();

// Increase request body size limit
app.use(express.json({ limit: "100mb" }));
app.use(express.urlencoded({ limit: "100mb", extended: true }));
app.use(cookieParser());
app.use(cors({ origin: "http://localhost:5173", credentials: true }));
app.use(bodyParser.json()); // Add body-parser middleware

// Nodemailer transporter
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: "idbsch2012@gmail.com", // Your Gmail address from .env
    pass: "bmdu vqxi dgqj dqoi", // Your Gmail app password from .env
  },
});

// Email endpoint
app.post("/api/send-email", (req, res) => {
  const { to_email, from_name, from_email, subject, message } = req.body;

  console.log("From email: ", from_email);
  console.log("Toemail: ", to_email);
  console.log("From name: ", from_name);
  console.log("Subject: ", subject);
  console.log("Message: ", message);

  const mailOptions = {
    from: `"${from_name}" <${from_email}>`, // Sender address
    to: to_email, // Recipient address
    subject: subject, // Email subject
    text: message, // Plain text body
    html: `<p>${message}</p>`, // HTML body
  };

  transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      console.error("Error sending email:", error);
      res.status(500).json({ success: false, message: "Failed to send email" });
    } else {
      console.log("Email sent:", info.response);
      res
        .status(200)
        .json({ success: true, message: "Email sent successfully" });
    }
  });
});

// API Routes
app.use("/api/user", userRoute);
app.use("/api/residence", residenceRouter);

// Start server
app.listen(PORT, () => {
  console.log("Server is listening on port " + PORT);
});
but when i console log i get the correct from email
(Due to technical issues, the search service is temporarily unavailable.)

The issue you're describing, where the from email is showing as the to email in Gmail, is likely due to how Gmail handles the from field in the email headers. Gmail may override the from field for security reasons, especially if you're using a Gmail account to send emails.

To fix this issue, you need to ensure that the from field is set correctly and that Gmail allows you to send emails on behalf of the sender's email address. Here's how you can resolve this:

Step 1: Update the mailOptions in the Backend
In your backend (index.js), ensure that the from field is set to your Gmail address (the one used in the transporter configuration). The replyTo field can be used to specify the sender's email address.

Hereâ€™s the updated mailOptions:

javascript
Copy
const mailOptions = {
  from: `"${from_name}" <idbsch2012@gmail.com>`, // Use your Gmail address here
  replyTo: from_email, // Set the reply-to address to the sender's email
  to: to_email, // Recipient address
  subject: subject, // Email subject
  text: message, // Plain text body
  html: `<p>${message}</p>`, // HTML body
};
Step 2: Update the transporter Configuration
Ensure that the transporter is configured correctly with your Gmail credentials:

javascript
Copy
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: "idbsch2012@gmail.com", // Your Gmail address
    pass: "bmdu vqxi dgqj dqoi", // Your Gmail app password
  },
});
Step 3: Test the Changes
Start the backend server:

bash
Copy
node index.js
Run your React app:

bash
Copy
npm start
Open the contact modal:

Fill out the form and submit it.

Check the recipient's inbox:

The email should now show the correct from address (idbsch2012@gmail.com) and the reply-to address (the sender's email).

Step 4: Verify the Email Headers
When you receive the email, check the email headers to ensure the from and reply-to fields are set correctly:

From: idbsch2012@gmail.com

Reply-To: The sender's email address (e.g., sender@example.com).

Why This Happens
Gmail has strict policies regarding the from field to prevent email spoofing. If you try to set the from field to an email address that doesn't belong to your Gmail account, Gmail will override it with the account's email address. By using the replyTo field, you can still allow recipients to reply to the sender's email address.

Final Code
Hereâ€™s the final updated index.js:

javascript
Copy
import express from "express";
import dotenv from "dotenv";
import cookieParser from "cookie-parser";
import cors from "cors";
import nodemailer from "nodemailer";
import bodyParser from "body-parser";

// Import routes
import userRoute from "./routes/userRoute.js";
import residenceRouter from "./routes/residenceRoute.js";

dotenv.config();
const PORT = process.env.PORT || 5000;

const app = express();

// Increase request body size limit
app.use(express.json({ limit: "100mb" }));
app.use(express.urlencoded({ limit: "100mb", extended: true }));
app.use(cookieParser());
app.use(cors({ origin: "http://localhost:5173", credentials: true }));
app.use(bodyParser.json()); // Add body-parser middleware

// Nodemailer transporter
const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: "idbsch2012@gmail.com", // Your Gmail address
    pass: "bmdu vqxi dgqj dqoi", // Your Gmail app password
  },
});

// Email endpoint
app.post("/api/send-email", (req, res) => {
  const { to_email, from_name, from_email, subject, message } = req.body;

  console.log("From email: ", from_email);
  console.log("To email: ", to_email);
  console.log("From name: ", from_name);
  console.log("Subject: ", subject);
  console.log("Message: ", message);

  const mailOptions = {
    from: `"${from_name}" <idbsch2012@gmail.com>`, // Use your Gmail address here
    replyTo: from_email, // Set the reply-to address to the sender's email
    to: to_email, // Recipient address
    subject: subject, // Email subject
    text: message, // Plain text body
    html: `<p>${message}</p>`, // HTML body
  };

  transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      console.error("Error sending email:", error);
      res.status(500).json({ success: false, message: "Failed to send email" });
    } else {
      console.log("Email sent:", info.response);
      res.status(200).json({ success: true, message: "Email sent successfully" });
    }
  });
});

// API Routes
app.use("/api/user", userRoute);
app.use("/api/residence", residenceRouter);

// Start server
app.listen(PORT, () => {
  console.log("Server is listening on port " + PORT);
});
Conclusion
By setting the from field to your Gmail address and using the replyTo field for the sender's email, you can ensure that the email is sent correctly and recipients can reply to the sender. This approach complies with Gmail's policies and prevents issues with email headers.

this is what i get:from:	Adnan Issah <idbsch2012@gmail.com>
reply-to:	gsakisco2013@gmial.com
to:	idbsch2012@gmail.com
date:	Mar 12, 2025, 9:19â€¯PM
subject:	Trying to buy your property
mailed-by:	gmail.com
(Due to technical issues, the search service is temporarily unavailable.)

The email headers you provided indicate that the email is being sent correctly, but there seems to be a misunderstanding about the expected behavior. Let me break it down for you:

Explanation of the Email Headers
from: Adnan Issah idbsch2012@gmail.com:

This is the sender's display name (Adnan Issah) and the email address (idbsch2012@gmail.com).

Gmail requires the from field to be the email address associated with the account sending the email. This is why idbsch2012@gmail.com appears here.

reply-to: gsakisco2013@gmial.com:

This is the email address where replies will be sent.

When someone clicks "Reply" in their email client, the reply will go to gsakisco2013@gmial.com.

to: idbsch2012@gmail.com:

This is the recipient's email address.

Since you hardcoded to_email as idbsch2012@gmail.com, the email is being sent to this address.

mailed-by: gmail.com:

This indicates that the email was sent through Gmail's servers.

Why This Happens
Gmail enforces strict rules to prevent email spoofing. If you try to set the from field to an email address that doesn't belong to your Gmail account, Gmail will override it with the account's email address (idbsch2012@gmail.com in this case). This is a security measure to prevent abuse.

How to Fix It
If you want the email to appear as if it's coming from the sender's email address (gsakisco2013@gmial.com), you have two options:

Option 1: Use Gmail's "Send Mail As" Feature
Add the Sender's Email to Your Gmail Account:

Go to your Gmail settings.

Navigate to Accounts and Import > Send mail as.

Click Add another email address.

Enter the sender's email address (gsakisco2013@gmial.com) and follow the verification steps.

Update the mailOptions in Your Backend:

Set the from field to the sender's email address (gsakisco2013@gmial.com).

javascript
Copy
const mailOptions = {
  from: `"${from_name}" <gsakisco2013@gmial.com>`, // Use the sender's email address
  to: to_email, // Recipient address
  subject: subject, // Email subject
  text: message, // Plain text body
  html: `<p>${message}</p>`, // HTML body
};
Test the Changes:

Send an email and check the headers. The from field should now show gsakisco2013@gmial.com.

Option 2: Use a Third-Party Email Service
If you don't want to use Gmail's "Send Mail As" feature, you can use a third-party email service like SendGrid, Mailgun, or Amazon SES. These services allow you to send emails from any email address without restrictions.

Hereâ€™s an example using SendGrid:

Sign up for SendGrid:

Go to SendGrid and create an account.

Verify your domain or email address.

Install SendGrid's Node.js SDK:

bash
Copy
npm install @sendgrid/mail
Update Your Backend:
Replace the Nodemailer code with SendGrid's SDK:

javascript
Copy
const sgMail = require("@sendgrid/mail");
sgMail.setApiKey(process.env.SENDGRID_API_KEY);

app.post("/api/send-email", (req, res) => {
  const { to_email, from_name, from_email, subject, message } = req.body;

  const msg = {
    to: to_email, // Recipient address
    from: `"${from_name}" <${from_email}>`, // Sender address
    subject: subject, // Email subject
    text: message, // Plain text body
    html: `<p>${message}</p>`, // HTML body
  };

  sgMail.send(msg)
    .then(() => {
      res.status(200).json({ success: true, message: "Email sent successfully" });
    })
    .catch((error) => {
      console.error("Error sending email:", error);
      res.status(500).json({ success: false, message: "Failed to send email" });
    });
});
Test the Changes:

Send an email and check the headers. The from field should now show the sender's email address.

Option 3: Use a Custom SMTP Server
If you have access to an SMTP server that allows you to send emails from any address, you can configure Nodemailer to use that server instead of Gmail.

Update the transporter Configuration:
Replace the Gmail configuration with your custom SMTP server details:

javascript
Copy
const transporter = nodemailer.createTransport({
  host: "smtp.yourdomain.com", // Your SMTP server host
  port: 587, // SMTP port (usually 587 for TLS)
  secure: false, // Use TLS
  auth: {
    user: "your-username", // SMTP username
    pass: "your-password", // SMTP password
  },
});
Update the mailOptions:
Set the from field to the sender's email address:

javascript
Copy
const mailOptions = {
  from: `"${from_name}" <${from_email}>`, // Use the sender's email address
  to: to_email, // Recipient address
  subject: subject, // Email subject
  text: message, // Plain text body
  html: `<p>${message}</p>`, // HTML body
};
Test the Changes:

Send an email and check the headers. The from field should now show the sender's email address.

Conclusion
The issue you're experiencing is due to Gmail's security policies. To send emails with a custom from address, you can either:

Use Gmail's "Send Mail As" feature.

Switch to a third-party email service like SendGrid.

Use a custom SMTP server.

Each option has its pros and cons, so choose the one that best fits your needs. Let me know if you need further assistance!

write a logic to implement this: import React from "react";
import "./Contact.css";
import { MdCall } from "react-icons/md";
import { BsChatDotsFill, BsFillChatDotsFill } from "react-icons/bs";
import { HiChatBubbleBottomCenter } from "react-icons/hi2";

function Contact() {
  return (
    <section className="c-wrapper">
      <div className="paddings innerWidth flexCenter c-container">
        {/* left-side */}
        <div className="flexColStart c-left">
          <span className="orangeText">Our Contacts</span>
          <span className="primaryText">Easy to contact us</span>
          <span className="secondaryText">
            We are always ready to help you by providing the best service to our
            clients. We believe that a good place to live can make your life
            better
          </span>
          <div className="flexColStart contactModes">
            {/* first Row */}
            <div className="flexStart row">
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <MdCall size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Call</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div className="flexCenter button">Call Now</div>
              </div>
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <BsChatDotsFill size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Chat</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div className="flexCenter button">Chat Now</div>
              </div>
            </div>
            {/* second row */}
            <div className="flexStart row">
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <MdCall size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Video Call</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div className="flexCenter button">Video Call Now</div>
              </div>
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <HiChatBubbleBottomCenter size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Message</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div className="flexCenter button">Message Now</div>
              </div>
            </div>
          </div>
        </div>
        {/* right-side */}
        <div className="flexColCenter c-right">
          <div className="image-container">
            <img src="./contact.jpg" alt="" />
          </div>
        </div>
      </div>
    </section>
  );
}

export default Contact;
(Due to technical issues, the search service is temporarily unavailable.)

To implement the logic for the Contact component, we need to add functionality to the buttons (Call Now, Chat Now, Video Call Now, and Message Now). Here's how you can do it:

Step 1: Add State and Event Handlers
We'll use React's useState to manage the state of each button (e.g., whether a call, chat, video call, or message is active). We'll also add event handlers to simulate the actions when the buttons are clicked.

Hereâ€™s the updated Contact component:

jsx
Copy
import React, { useState } from "react";
import "./Contact.css";
import { MdCall } from "react-icons/md";
import { BsChatDotsFill } from "react-icons/bs";
import { HiChatBubbleBottomCenter } from "react-icons/hi2";

function Contact() {
  // State to manage active modes
  const [activeMode, setActiveMode] = useState(null);

  // Event handlers for each mode
  const handleCall = () => {
    setActiveMode("call");
    // Simulate a call action
    window.location.href = "tel:+10550287057";
  };

  const handleChat = () => {
    setActiveMode("chat");
    // Simulate opening a chat (e.g., redirect to a chat app or open a chat modal)
    alert("Chat feature is not implemented yet.");
  };

  const handleVideoCall = () => {
    setActiveMode("videoCall");
    // Simulate a video call action (e.g., redirect to a video call app)
    alert("Video call feature is not implemented yet.");
  };

  const handleMessage = () => {
    setActiveMode("message");
    // Simulate sending a message (e.g., redirect to a messaging app or open a message modal)
    alert("Message feature is not implemented yet.");
  };

  return (
    <section className="c-wrapper">
      <div className="paddings innerWidth flexCenter c-container">
        {/* left-side */}
        <div className="flexColStart c-left">
          <span className="orangeText">Our Contacts</span>
          <span className="primaryText">Easy to contact us</span>
          <span className="secondaryText">
            We are always ready to help you by providing the best service to our
            clients. We believe that a good place to live can make your life
            better
          </span>
          <div className="flexColStart contactModes">
            {/* first Row */}
            <div className="flexStart row">
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <MdCall size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Call</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "call" ? "active" : ""
                  }`}
                  onClick={handleCall}
                >
                  Call Now
                </div>
              </div>
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <BsChatDotsFill size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Chat</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "chat" ? "active" : ""
                  }`}
                  onClick={handleChat}
                >
                  Chat Now
                </div>
              </div>
            </div>
            {/* second row */}
            <div className="flexStart row">
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <MdCall size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Video Call</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "videoCall" ? "active" : ""
                  }`}
                  onClick={handleVideoCall}
                >
                  Video Call Now
                </div>
              </div>
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <HiChatBubbleBottomCenter size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Message</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "message" ? "active" : ""
                  }`}
                  onClick={handleMessage}
                >
                  Message Now
                </div>
              </div>
            </div>
          </div>
        </div>
        {/* right-side */}
        <div className="flexColCenter c-right">
          <div className="image-container">
            <img src="./contact.jpg" alt="" />
          </div>
        </div>
      </div>
    </section>
  );
}

export default Contact;
Step 2: Add CSS for Active State
Update your Contact.css to style the active button:

css
Copy
.button {
  background-color: #f0f0f0;
  padding: 10px 20px;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.button.active {
  background-color: #007bff;
  color: white;
}

.button:hover {
  background-color: #007bff;
  color: white;
}
Step 3: Test the Component
Call Now:

Clicking the "Call Now" button will trigger a phone call (on mobile devices) or show an alert (on desktop).

Chat Now:

Clicking the "Chat Now" button will show an alert (you can replace this with a chat modal or redirect to a chat app).

Video Call Now:

Clicking the "Video Call Now" button will show an alert (you can replace this with a video call integration like Zoom or Google Meet).

Message Now:

Clicking the "Message Now" button will show an alert (you can replace this with a messaging modal or redirect to a messaging app).

Step 4: Enhance Functionality (Optional)
If you want to implement actual functionality (e.g., chat, video call, or messaging), you can integrate third-party services like:

Chat: Use a chat API like Twilio or Socket.io.

Video Call: Use a video call API like Zoom or Jitsi.

Messaging: Use an SMS API like Twilio or an email API like SendGrid.

Conclusion
The updated Contact component now includes logic for handling button clicks and simulating actions. You can further enhance the functionality by integrating third-party services for chat, video calls, and messaging. Let me know if you need help with any specific integration!

this is my contact.css: .c-container {
  justify-content: space-between;
}
.c-container > div {
  flex: 1;
}
.c-right {
  width: 100%;
}
.c-left {
  gap: 0.5rem;
}

.contactModes {
  margin-top: 2rem;
  gap: 1rem;
}
.contactModes .row {
  gap: 1.5rem;
}
.mode {
  width: 16rem;
  padding: 1rem;
  border: 0.8px solid rgba(128, 128, 128, 0.143);
  border-radius: 5px;
  gap: 1rem;
  transition: all 300ms ease-in;
}
.mode .button {
  width: 100%;
  background: var(--lightBlue);
  color: var(--blue);
  font-size: 0.9rem;
  font-weight: 600;
}
.mode > :nth-child(1) {
  width: 100%;
  gap: 1.6rem;
}
.mode .description .primaryText {
  font-size: 1.1rem;
  font-weight: 600;
}
.mode:hover {
  scale: 1.1;
  box-shadow: var(--shadow);
}
.mode .button:hover {
  background: var(--blue-gradient);
  color: white;
  scale: 0.8;
}

@media (max-width: 1024px) {
  .c-container {
    flex-direction: column;
  }
  .c-right {
    justify-content: center;
  }
  .contactModes {
    width: 100%;
  }
  .row {
    flex-direction: column;
    width: 100%;
  }
  .mode {
    width: 100%;
  }
}
(Due to technical issues, the search service is temporarily unavailable.)

To enhance the Contact.css file and ensure it works seamlessly with the updated Contact component (which includes active states for buttons), we need to add styles for the active state of the buttons and ensure the hover effects are consistent. Here's the updated Contact.css:

Updated Contact.css
css
Copy
.c-container {
  justify-content: space-between;
}

.c-container > div {
  flex: 1;
}

.c-right {
  width: 100%;
}

.c-left {
  gap: 0.5rem;
}

.contactModes {
  margin-top: 2rem;
  gap: 1rem;
}

.contactModes .row {
  gap: 1.5rem;
}

.mode {
  width: 16rem;
  padding: 1rem;
  border: 0.8px solid rgba(128, 128, 128, 0.143);
  border-radius: 5px;
  gap: 1rem;
  transition: all 300ms ease-in;
}

.mode .button {
  width: 100%;
  background: var(--lightBlue);
  color: var(--blue);
  font-size: 0.9rem;
  font-weight: 600;
  border: none;
  border-radius: 5px;
  padding: 10px 20px;
  cursor: pointer;
  transition: all 300ms ease-in;
}

.mode .button.active {
  background: var(--blue-gradient);
  color: white;
}

.mode > :nth-child(1) {
  width: 100%;
  gap: 1.6rem;
}

.mode .description .primaryText {
  font-size: 1.1rem;
  font-weight: 600;
}

.mode:hover {
  scale: 1.1;
  box-shadow: var(--shadow);
}

.mode .button:hover {
  background: var(--blue-gradient);
  color: white;
  scale: 0.95;
}

/* Responsive Design */
@media (max-width: 1024px) {
  .c-container {
    flex-direction: column;
  }

  .c-right {
    justify-content: center;
  }

  .contactModes {
    width: 100%;
  }

  .row {
    flex-direction: column;
    width: 100%;
  }

  .mode {
    width: 100%;
  }
}
Key Changes
Button Active State:

Added .mode .button.active to style the active state of the button.

The active button will have a gradient background (var(--blue-gradient)) and white text.

Button Hover State:

Updated .mode .button:hover to ensure the hover effect is consistent with the active state.

Added a slight scale effect (scale: 0.95) to make the button feel interactive.

Button Transition:

Added transition: all 300ms ease-in to .mode .button for smooth hover and active state transitions.

Responsive Design:

Ensured the layout remains responsive for screens smaller than 1024px.

How It Works
When a button is clicked, it will receive the active class, which applies the var(--blue-gradient) background and white text.

The hover effect (:hover) is consistent with the active state, ensuring a seamless user experience.

The buttons will scale slightly when hovered or clicked, providing visual feedback.

Example Usage
With the updated CSS, the Contact component will now display active and hover states correctly. For example:

jsx
Copy
<div className="flexColCenter mode">
  <div className="flexStart">
    <div className="flexCenter icon">
      <MdCall size={25} />
    </div>
    <div className="flexColStart description">
      <span className="primaryText">Call</span>
      <span className="secondaryText">1 055 028 7057</span>
    </div>
  </div>
  <div
    className={`flexCenter button ${
      activeMode === "call" ? "active" : ""
    }`}
    onClick={handleCall}
  >
    Call Now
  </div>
</div>
When the "Call Now" button is clicked, it will have the active class applied, and the button will change its appearance according to the .mode .button.active styles.

Testing
Hover Effect:

Hover over any button to see the gradient background and slight scale effect.

Active State:

Click a button to see it change to the active state (gradient background and white text).

Responsive Design:

Resize the browser window to ensure the layout adapts correctly for smaller screens.

Conclusion
The updated Contact.css ensures that the Contact component looks great and provides a smooth user experience with active and hover states for the buttons. Let me know if you need further adjustments or enhancements!

how do i implement the this in real life. do not change my code. add all necessary functions: import React, { useState } from "react";
import "./Contact.css";
import { MdCall } from "react-icons/md";
import { BsChatDotsFill } from "react-icons/bs";
import { HiChatBubbleBottomCenter } from "react-icons/hi2";

function Contact() {
  // State to manage active modes
  const [activeMode, setActiveMode] = useState(null);

  // Event handlers for each mode
  const handleCall = () => {
    setActiveMode("call");
    // Simulate a call action
    window.location.href = "tel:+10550287057";
  };

  const handleChat = () => {
    setActiveMode("chat");
    // Simulate opening a chat (e.g., redirect to a chat app or open a chat modal)
    alert("Chat feature is not implemented yet.");
  };

  const handleVideoCall = () => {
    setActiveMode("videoCall");
    // Simulate a video call action (e.g., redirect to a video call app)
    alert("Video call feature is not implemented yet.");
  };

  const handleMessage = () => {
    setActiveMode("message");
    // Simulate sending a message (e.g., redirect to a messaging app or open a message modal)
    alert("Message feature is not implemented yet.");
  };

  return (
    <section className="c-wrapper">
      <div className="paddings innerWidth flexCenter c-container">
        {/* left-side */}
        <div className="flexColStart c-left">
          <span className="orangeText">Our Contacts</span>
          <span className="primaryText">Easy to contact us</span>
          <span className="secondaryText">
            We are always ready to help you by providing the best service to our
            clients. We believe that a good place to live can make your life
            better
          </span>
          <div className="flexColStart contactModes">
            {/* first Row */}
            <div className="flexStart row">
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <MdCall size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Call</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "call" ? "active" : ""
                  }`}
                  onClick={handleCall}
                >
                  Call Now
                </div>
              </div>
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <BsChatDotsFill size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Chat</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "chat" ? "active" : ""
                  }`}
                  onClick={handleChat}
                >
                  Chat Now
                </div>
              </div>
            </div>
            {/* second row */}
            <div className="flexStart row">
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <MdCall size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Video Call</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "videoCall" ? "active" : ""
                  }`}
                  onClick={handleVideoCall}
                >
                  Video Call Now
                </div>
              </div>
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <HiChatBubbleBottomCenter size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Message</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "message" ? "active" : ""
                  }`}
                  onClick={handleMessage}
                >
                  Message Now
                </div>
              </div>
            </div>
          </div>
        </div>
        {/* right-side */}
        <div className="flexColCenter c-right">
          <div className="image-container">
            <img src="./contact.jpg" alt="" />
          </div>
        </div>
      </div>
    </section>
  );
}

export default Contact;
(Due to technical issues, the search service is temporarily unavailable.)

To implement the functionality of the Contact component in real life, we need to replace the placeholder logic (e.g., alert) with actual implementations for Call, Chat, Video Call, and Message. Below, I'll provide step-by-step instructions to implement each feature without changing your existing code structure.

Step 1: Implement Call Functionality
The Call functionality is already implemented correctly using window.location.href = "tel:+10550287057";. This will work on mobile devices to initiate a phone call. On desktop, it will do nothing (or open a dialer if supported).

Step 2: Implement Chat Functionality
For the Chat feature, you can integrate a live chat solution like WhatsApp, Facebook Messenger, or a custom chat widget.

Option 1: Redirect to WhatsApp
Update the handleChat function to redirect users to WhatsApp:

javascript
Copy
const handleChat = () => {
  setActiveMode("chat");
  // Redirect to WhatsApp with a predefined message
  const phoneNumber = "10550287057"; // Replace with your phone number
  const message = "Hello, I would like to chat with you."; // Predefined message
  const url = `https://wa.me/${phoneNumber}?text=${encodeURIComponent(message)}`;
  window.open(url, "_blank");
};
Option 2: Integrate a Chat Widget
If you want to embed a chat widget, you can use services like Tidio, Intercom, or Crisp. Add their script to your project and initialize the chat widget.

Step 3: Implement Video Call Functionality
For the Video Call feature, you can integrate a video conferencing solution like Zoom, Google Meet, or Jitsi.

Option 1: Redirect to Google Meet
Update the handleVideoCall function to create a Google Meet link:

javascript
Copy
const handleVideoCall = () => {
  setActiveMode("videoCall");
  // Redirect to Google Meet
  const meetingLink = "https://meet.google.com/new"; // Replace with your meeting link
  window.open(meetingLink, "_blank");
};
Option 2: Embed Jitsi Meet
You can embed Jitsi Meet directly into your app:

Install the Jitsi Meet library:

bash
Copy
npm install @jitsi/react-sdk
Create a VideoCallModal.jsx component:

jsx
Copy
import React from "react";
import { JitsiMeeting } from "@jitsi/react-sdk";

const VideoCallModal = ({ onClose }) => {
  return (
    <div className="video-call-modal">
      <JitsiMeeting
        roomName="YourRoomName"
        getIFrameRef={(iframeRef) => {
          iframeRef.style.height = "500px";
        }}
        configOverwrite={{
          startWithAudioMuted: true,
          startWithVideoMuted: false,
        }}
        interfaceConfigOverwrite={{
          SHOW_JITSI_WATERMARK: false,
        }}
        onApiReady={(api) => {
          console.log("Jitsi Meet API ready", api);
        }}
      />
      <button onClick={onClose}>Close</button>
    </div>
  );
};

export default VideoCallModal;
Update the handleVideoCall function to open the modal:

javascript
Copy
const [isVideoCallModalOpen, setIsVideoCallModalOpen] = useState(false);

const handleVideoCall = () => {
  setActiveMode("videoCall");
  setIsVideoCallModalOpen(true);
};
Render the VideoCallModal in the Contact component:

jsx
Copy
{isVideoCallModalOpen && (
  <VideoCallModal onClose={() => setIsVideoCallModalOpen(false)} />
)}
Step 4: Implement Message Functionality
For the Message feature, you can integrate an SMS or email solution.

Option 1: Redirect to SMS
Update the handleMessage function to open the default SMS app:

javascript
Copy
const handleMessage = () => {
  setActiveMode("message");
  // Open SMS app with a predefined message
  const phoneNumber = "10550287057"; // Replace with your phone number
  const message = "Hello, I would like to message you."; // Predefined message
  const url = `sms:${phoneNumber}?body=${encodeURIComponent(message)}`;
  window.open(url, "_blank");
};
Option 2: Send an Email
Update the handleMessage function to open the default email client:

javascript
Copy
const handleMessage = () => {
  setActiveMode("message");
  // Open email client with a predefined message
  const email = "idbsch2012@gmail.com"; // Replace with your email
  const subject = "Inquiry"; // Predefined subject
  const body = "Hello, I would like to message you."; // Predefined body
  const url = `mailto:${email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
  window.open(url, "_blank");
};
Step 5: Final Code with All Implementations
Hereâ€™s the final Contact component with all functionalities implemented:

jsx
Copy
import React, { useState } from "react";
import "./Contact.css";
import { MdCall } from "react-icons/md";
import { BsChatDotsFill } from "react-icons/bs";
import { HiChatBubbleBottomCenter } from "react-icons/hi2";

function Contact() {
  // State to manage active modes
  const [activeMode, setActiveMode] = useState(null);
  const [isVideoCallModalOpen, setIsVideoCallModalOpen] = useState(false);

  // Event handlers for each mode
  const handleCall = () => {
    setActiveMode("call");
    // Simulate a call action
    window.location.href = "tel:+10550287057";
  };

  const handleChat = () => {
    setActiveMode("chat");
    // Redirect to WhatsApp
    const phoneNumber = "10550287057"; // Replace with your phone number
    const message = "Hello, I would like to chat with you."; // Predefined message
    const url = `https://wa.me/${phoneNumber}?text=${encodeURIComponent(message)}`;
    window.open(url, "_blank");
  };

  const handleVideoCall = () => {
    setActiveMode("videoCall");
    // Open Google Meet
    const meetingLink = "https://meet.google.com/new"; // Replace with your meeting link
    window.open(meetingLink, "_blank");
  };

  const handleMessage = () => {
    setActiveMode("message");
    // Open email client
    const email = "idbsch2012@gmail.com"; // Replace with your email
    const subject = "Inquiry"; // Predefined subject
    const body = "Hello, I would like to message you."; // Predefined body
    const url = `mailto:${email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
    window.open(url, "_blank");
  };

  return (
    <section className="c-wrapper">
      <div className="paddings innerWidth flexCenter c-container">
        {/* left-side */}
        <div className="flexColStart c-left">
          <span className="orangeText">Our Contacts</span>
          <span className="primaryText">Easy to contact us</span>
          <span className="secondaryText">
            We are always ready to help you by providing the best service to our
            clients. We believe that a good place to live can make your life
            better
          </span>
          <div className="flexColStart contactModes">
            {/* first Row */}
            <div className="flexStart row">
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <MdCall size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Call</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "call" ? "active" : ""
                  }`}
                  onClick={handleCall}
                >
                  Call Now
                </div>
              </div>
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <BsChatDotsFill size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Chat</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "chat" ? "active" : ""
                  }`}
                  onClick={handleChat}
                >
                  Chat Now
                </div>
              </div>
            </div>
            {/* second row */}
            <div className="flexStart row">
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <MdCall size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Video Call</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "videoCall" ? "active" : ""
                  }`}
                  onClick={handleVideoCall}
                >
                  Video Call Now
                </div>
              </div>
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <HiChatBubbleBottomCenter size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Message</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "message" ? "active" : ""
                  }`}
                  onClick={handleMessage}
                >
                  Message Now
                </div>
              </div>
            </div>
          </div>
        </div>
        {/* right-side */}
        <div className="flexColCenter c-right">
          <div className="image-container">
            <img src="./contact.jpg" alt="" />
          </div>
        </div>
      </div>
    </section>
  );
}

export default Contact;
Step 6: Test the Functionality
Call Now:

On mobile, clicking the button will initiate a call to +10550287057.

On desktop, it will do nothing (or open a dialer if supported).

Chat Now:

Clicking the button will open WhatsApp with a predefined message.

Video Call Now:

Clicking the button will open Google Meet in a new tab.

Message Now:

Clicking the button will open the default email client with a predefined message.

Conclusion
The Contact component now has real-life functionality for Call, Chat, Video Call, and Message. You can further enhance it by integrating more advanced features like a custom chat widget or video conferencing API. Let me know if you need help with any specific integration!

can i add multiple options. if yes, write the step by step procedure
(Due to technical issues, the search service is temporarily unavailable.)

Yes, you can add multiple options for each functionality (e.g., Chat, Video Call, Message) to give users a choice of how they want to contact you. For example, for the Chat feature, you can provide options like WhatsApp, Facebook Messenger, and Telegram. Similarly, for Video Call, you can offer Google Meet, Zoom, and Jitsi.

Hereâ€™s a step-by-step guide to implement multiple options for each functionality:

Step 1: Add a Dropdown or Modal for Multiple Options
You can use a dropdown menu or a modal to display multiple options for each functionality. For simplicity, I'll use a modal in this example.

Step 2: Create a Modal Component
Create a new component called OptionsModal.jsx to display multiple options:

jsx
Copy
import React from "react";
import "./OptionsModal.css"; // Add CSS for the modal

const OptionsModal = ({ options, onSelect, onClose }) => {
  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <button className="close-button" onClick={onClose}>
          &times;
        </button>
        <h2>Choose an Option</h2>
        <div className="options-list">
          {options.map((option, index) => (
            <div
              key={index}
              className="option"
              onClick={() => onSelect(option)}
            >
              {option.label}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

export default OptionsModal;
Step 3: Add CSS for the Modal
Create a file OptionsModal.css to style the modal:

css
Copy
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  padding: 20px;
  border-radius: 8px;
  width: 100%;
  max-width: 400px;
  position: relative;
}

.close-button {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
}

.options-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.option {
  padding: 10px;
  background: #f0f0f0;
  border-radius: 5px;
  cursor: pointer;
  transition: background 0.3s ease;
}

.option:hover {
  background: #007bff;
  color: white;
}
Step 4: Update the Contact Component
Add State for the Modal:

Use useState to manage the visibility of the modal and the selected functionality.

Define Options for Each Functionality:

Create an array of options for Chat, Video Call, and Message.

Handle Option Selection:

When an option is selected, perform the corresponding action (e.g., open WhatsApp, Google Meet, etc.).

Hereâ€™s the updated Contact component:

jsx
Copy
import React, { useState } from "react";
import "./Contact.css";
import { MdCall } from "react-icons/md";
import { BsChatDotsFill } from "react-icons/bs";
import { HiChatBubbleBottomCenter } from "react-icons/hi2";
import OptionsModal from "./OptionsModal"; // Import the OptionsModal

function Contact() {
  const [activeMode, setActiveMode] = useState(null);
  const [isOptionsModalOpen, setIsOptionsModalOpen] = useState(false);
  const [currentOptions, setCurrentOptions] = useState([]);

  // Define options for each functionality
  const chatOptions = [
    { label: "WhatsApp", action: () => window.open("https://wa.me/10550287057", "_blank") },
    { label: "Facebook Messenger", action: () => window.open("https://m.me/yourpage", "_blank") },
    { label: "Telegram", action: () => window.open("https://t.me/yourusername", "_blank") },
  ];

  const videoCallOptions = [
    { label: "Google Meet", action: () => window.open("https://meet.google.com/new", "_blank") },
    { label: "Zoom", action: () => window.open("https://zoom.us/", "_blank") },
    { label: "Jitsi Meet", action: () => window.open("https://meet.jit.si/", "_blank") },
  ];

  const messageOptions = [
    { label: "Email", action: () => window.open("mailto:idbsch2012@gmail.com", "_blank") },
    { label: "SMS", action: () => window.open("sms:+10550287057", "_blank") },
  ];

  // Event handlers for each mode
  const handleCall = () => {
    setActiveMode("call");
    window.location.href = "tel:+10550287057";
  };

  const handleChat = () => {
    setActiveMode("chat");
    setCurrentOptions(chatOptions);
    setIsOptionsModalOpen(true);
  };

  const handleVideoCall = () => {
    setActiveMode("videoCall");
    setCurrentOptions(videoCallOptions);
    setIsOptionsModalOpen(true);
  };

  const handleMessage = () => {
    setActiveMode("message");
    setCurrentOptions(messageOptions);
    setIsOptionsModalOpen(true);
  };

  // Handle option selection
  const handleOptionSelect = (option) => {
    option.action(); // Perform the action associated with the option
    setIsOptionsModalOpen(false); // Close the modal
  };

  return (
    <section className="c-wrapper">
      <div className="paddings innerWidth flexCenter c-container">
        {/* left-side */}
        <div className="flexColStart c-left">
          <span className="orangeText">Our Contacts</span>
          <span className="primaryText">Easy to contact us</span>
          <span className="secondaryText">
            We are always ready to help you by providing the best service to our
            clients. We believe that a good place to live can make your life
            better
          </span>
          <div className="flexColStart contactModes">
            {/* first Row */}
            <div className="flexStart row">
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <MdCall size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Call</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "call" ? "active" : ""
                  }`}
                  onClick={handleCall}
                >
                  Call Now
                </div>
              </div>
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <BsChatDotsFill size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Chat</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "chat" ? "active" : ""
                  }`}
                  onClick={handleChat}
                >
                  Chat Now
                </div>
              </div>
            </div>
            {/* second row */}
            <div className="flexStart row">
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <MdCall size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Video Call</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "videoCall" ? "active" : ""
                  }`}
                  onClick={handleVideoCall}
                >
                  Video Call Now
                </div>
              </div>
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <HiChatBubbleBottomCenter size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Message</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "message" ? "active" : ""
                  }`}
                  onClick={handleMessage}
                >
                  Message Now
                </div>
              </div>
            </div>
          </div>
        </div>
        {/* right-side */}
        <div className="flexColCenter c-right">
          <div className="image-container">
            <img src="./contact.jpg" alt="" />
          </div>
        </div>
      </div>

      {/* Options Modal */}
      {isOptionsModalOpen && (
        <OptionsModal
          options={currentOptions}
          onSelect={handleOptionSelect}
          onClose={() => setIsOptionsModalOpen(false)}
        />
      )}
    </section>
  );
}

export default Contact;
Step 5: Test the Functionality
Chat Now:

Clicking the "Chat Now" button will open a modal with options like WhatsApp, Facebook Messenger, and Telegram.

Selecting an option will redirect the user to the respective platform.

Video Call Now:

Clicking the "Video Call Now" button will open a modal with options like Google Meet, Zoom, and Jitsi Meet.

Selecting an option will redirect the user to the respective platform.

Message Now:

Clicking the "Message Now" button will open a modal with options like Email and SMS.

Selecting an option will open the default email client or SMS app.

Conclusion
By adding multiple options for each functionality, you provide users with flexibility in how they contact you. This approach enhances the user experience and ensures that users can choose the method they are most comfortable with. Let me know if you need further assistance!

add whatsapp video call:   const videoCallOptions = [
    { label: "Google Meet", action: () => window.open("https://meet.google.com/new", "_blank") },
    { label: "Zoom", action: () => window.open("https://zoom.us/", "_blank") },
  ];
(Due to technical issues, the search service is temporarily unavailable.)

To add WhatsApp Video Call as an option in the videoCallOptions array, you can use the WhatsApp video call link format. WhatsApp allows users to initiate video calls directly via a link.

Hereâ€™s how you can add it:

Step 1: Add WhatsApp Video Call Option
Update the videoCallOptions array in your Contact component to include WhatsApp Video Call:

javascript
Copy
const videoCallOptions = [
  { label: "Google Meet", action: () => window.open("https://meet.google.com/new", "_blank") },
  { label: "Zoom", action: () => window.open("https://zoom.us/", "_blank") },
  { label: "WhatsApp Video Call", action: () => window.open("https://wa.me/10550287057", "_blank") },
];
Step 2: Test the WhatsApp Video Call Option
Click the "Video Call Now" Button:

This will open the modal with the options: Google Meet, Zoom, and WhatsApp Video Call.

Select "WhatsApp Video Call":

This will open WhatsApp in a new tab with the phone number pre-filled.

The user can then manually initiate a video call from WhatsApp.

Notes
WhatsApp does not support direct video call links. The https://wa.me/ link only opens a chat with the specified phone number. The user must manually start the video call from the chat.

If you want to automate the video call process, you would need to use a third-party service or API that integrates with WhatsApp's video call feature.

Updated Contact Component
Hereâ€™s the updated Contact component with the WhatsApp Video Call option:

jsx
Copy
import React, { useState } from "react";
import "./Contact.css";
import { MdCall } from "react-icons/md";
import { BsChatDotsFill } from "react-icons/bs";
import { HiChatBubbleBottomCenter } from "react-icons/hi2";
import OptionsModal from "./OptionsModal"; // Import the OptionsModal

function Contact() {
  const [activeMode, setActiveMode] = useState(null);
  const [isOptionsModalOpen, setIsOptionsModalOpen] = useState(false);
  const [currentOptions, setCurrentOptions] = useState([]);

  // Define options for each functionality
  const chatOptions = [
    { label: "WhatsApp", action: () => window.open("https://wa.me/10550287057", "_blank") },
    { label: "Facebook Messenger", action: () => window.open("https://m.me/yourpage", "_blank") },
    { label: "Telegram", action: () => window.open("https://t.me/yourusername", "_blank") },
  ];

  const videoCallOptions = [
    { label: "Google Meet", action: () => window.open("https://meet.google.com/new", "_blank") },
    { label: "Zoom", action: () => window.open("https://zoom.us/", "_blank") },
    { label: "WhatsApp Video Call", action: () => window.open("https://wa.me/10550287057", "_blank") },
  ];

  const messageOptions = [
    { label: "Email", action: () => window.open("mailto:idbsch2012@gmail.com", "_blank") },
    { label: "SMS", action: () => window.open("sms:+10550287057", "_blank") },
  ];

  // Event handlers for each mode
  const handleCall = () => {
    setActiveMode("call");
    window.location.href = "tel:+10550287057";
  };

  const handleChat = () => {
    setActiveMode("chat");
    setCurrentOptions(chatOptions);
    setIsOptionsModalOpen(true);
  };

  const handleVideoCall = () => {
    setActiveMode("videoCall");
    setCurrentOptions(videoCallOptions);
    setIsOptionsModalOpen(true);
  };

  const handleMessage = () => {
    setActiveMode("message");
    setCurrentOptions(messageOptions);
    setIsOptionsModalOpen(true);
  };

  // Handle option selection
  const handleOptionSelect = (option) => {
    option.action(); // Perform the action associated with the option
    setIsOptionsModalOpen(false); // Close the modal
  };

  return (
    <section className="c-wrapper">
      <div className="paddings innerWidth flexCenter c-container">
        {/* left-side */}
        <div className="flexColStart c-left">
          <span className="orangeText">Our Contacts</span>
          <span className="primaryText">Easy to contact us</span>
          <span className="secondaryText">
            We are always ready to help you by providing the best service to our
            clients. We believe that a good place to live can make your life
            better
          </span>
          <div className="flexColStart contactModes">
            {/* first Row */}
            <div className="flexStart row">
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <MdCall size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Call</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "call" ? "active" : ""
                  }`}
                  onClick={handleCall}
                >
                  Call Now
                </div>
              </div>
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <BsChatDotsFill size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Chat</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "chat" ? "active" : ""
                  }`}
                  onClick={handleChat}
                >
                  Chat Now
                </div>
              </div>
            </div>
            {/* second row */}
            <div className="flexStart row">
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <MdCall size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Video Call</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "videoCall" ? "active" : ""
                  }`}
                  onClick={handleVideoCall}
                >
                  Video Call Now
                </div>
              </div>
              <div className="flexColCenter mode">
                <div className="flexStart">
                  <div className="flexCenter icon">
                    <HiChatBubbleBottomCenter size={25} />
                  </div>
                  <div className="flexColStart description">
                    <span className="primaryText">Message</span>
                    <span className="secondaryText">1 055 028 7057</span>
                  </div>
                </div>
                <div
                  className={`flexCenter button ${
                    activeMode === "message" ? "active" : ""
                  }`}
                  onClick={handleMessage}
                >
                  Message Now
                </div>
              </div>
            </div>
          </div>
        </div>
        {/* right-side */}
        <div className="flexColCenter c-right">
          <div className="image-container">
            <img src="./contact.jpg" alt="" />
          </div>
        </div>
      </div>

      {/* Options Modal */}
      {isOptionsModalOpen && (
        <OptionsModal
          options={currentOptions}
          onSelect={handleOptionSelect}
          onClose={() => setIsOptionsModalOpen(false)}
        />
      )}
    </section>
  );
}

export default Contact;
Step 3: Test the WhatsApp Video Call Option
Click the "Video Call Now" Button:

This will open the modal with the options: Google Meet, Zoom, and WhatsApp Video Call.

Select "WhatsApp Video Call":

This will open WhatsApp in a new tab with the phone number pre-filled.

The user can then manually initiate a video call from WhatsApp.

Conclusion
By adding WhatsApp Video Call as an option, you provide users with another way to contact you via video call. While WhatsApp does not support direct video call links, the https://wa.me/ link simplifies the process by opening a chat with the specified phone number. Let me know if you need further assistance!

i want to implement subscription: import React from "react";
import "./GetStarted.css";

function GetStarted() {
  return (
    <section className="g-wrapper">
      <div className="paddings innerWidth g-container">
        <div className="flexColCenter inner-container">
          <span className="primaryText">
            Get Started with AetherSoft Realtors
          </span>
          <span className="secondaryText">
            Subscribe and find super attractive price quotes from us <br /> Find
            your dream property now
          </span>
          <button className="button">
            <a href="">Get Started</a>
          </button>
        </div>
      </div>
    </section>
  );
}

export default GetStarted;
(Due to technical issues, the search service is temporarily unavailable.)

To implement a subscription feature in your GetStarted component, you can add a form where users can enter their email address to subscribe. You can then send this email to your backend or a third-party service (e.g., Mailchimp, SendGrid) to handle the subscription.

Hereâ€™s how you can implement it step by step:

Step 1: Add a Subscription Form
Update the GetStarted component to include a subscription form:

jsx
Copy
import React, { useState } from "react";
import "./GetStarted.css";

function GetStarted() {
  const [email, setEmail] = useState("");
  const [subscribed, setSubscribed] = useState(false);
  const [error, setError] = useState("");

  const handleSubmit = async (e) => {
    e.preventDefault();

    // Validate email
    if (!email || !email.includes("@")) {
      setError("Please enter a valid email address.");
      return;
    }

    try {
      // Send the email to your backend or third-party service
      const response = await fetch("http://localhost:5000/api/subscribe", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email }),
      });

      if (response.ok) {
        setSubscribed(true);
        setError("");
      } else {
        setError("Failed to subscribe. Please try again later.");
      }
    } catch (error) {
      console.error("Error:", error);
      setError("An error occurred. Please try again later.");
    }
  };

  return (
    <section className="g-wrapper">
      <div className="paddings innerWidth g-container">
        <div className="flexColCenter inner-container">
          <span className="primaryText">
            Get Started with AetherSoft Realtors
          </span>
          <span className="secondaryText">
            Subscribe and find super attractive price quotes from us <br /> Find
            your dream property now
          </span>

          {subscribed ? (
            <p className="success-message">Thank you for subscribing!</p>
          ) : (
            <form onSubmit={handleSubmit} className="subscription-form">
              <input
                type="email"
                placeholder="Enter your email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
              />
              <button type="submit" className="button">
                Subscribe
              </button>
            </form>
          )}

          {error && <p className="error-message">{error}</p>}
        </div>
      </div>
    </section>
  );
}

export default GetStarted;
Step 2: Add CSS for the Subscription Form
Update your GetStarted.css to style the subscription form:

css
Copy
.g-wrapper {
  background: var(--lightBlue);
  padding: 2rem 0;
}

.g-container {
  display: flex;
  justify-content: center;
  align-items: center;
}

.inner-container {
  text-align: center;
  gap: 1rem;
}

.primaryText {
  font-size: 2rem;
  font-weight: 600;
  color: var(--black);
}

.secondaryText {
  font-size: 1rem;
  color: var(--gray);
}

.subscription-form {
  display: flex;
  gap: 1rem;
  margin-top: 1rem;
}

.subscription-form input {
  padding: 0.8rem;
  border: 1px solid #ccc;
  border-radius: 5px;
  width: 250px;
  font-size: 1rem;
}

.subscription-form input:focus {
  outline: none;
  border-color: var(--blue);
}

.button {
  background: var(--blue-gradient);
  color: white;
  padding: 0.8rem 1.5rem;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 1rem;
  transition: background 0.3s ease;
}

.button:hover {
  background: var(--blue);
}

.success-message {
  color: green;
  font-size: 1rem;
  margin-top: 1rem;
}

.error-message {
  color: red;
  font-size: 1rem;
  margin-top: 1rem;
}
Step 3: Set Up the Backend
Create a backend endpoint to handle the subscription request. Hereâ€™s an example using Node.js and Express:

Backend Code (index.js)
javascript
Copy
import express from "express";
import bodyParser from "body-parser";

const app = express();
const PORT = 5000;

app.use(bodyParser.json());

// Mock database to store subscriptions
const subscriptions = [];

// Subscription endpoint
app.post("/api/subscribe", (req, res) => {
  const { email } = req.body;

  if (!email || !email.includes("@")) {
    return res.status(400).json({ success: false, message: "Invalid email address." });
  }

  // Add email to the database (or send it to a third-party service)
  subscriptions.push(email);

  console.log("New subscription:", email);
  res.status(200).json({ success: true, message: "Subscription successful!" });
});

// Start server
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
Step 4: Test the Subscription Feature
Start the Backend Server:

bash
Copy
node index.js
Run Your React App:

bash
Copy
npm start
Enter an Email Address:

In the GetStarted component, enter a valid email address and click "Subscribe".

Check the Console:

The backend will log the new subscription (e.g., New subscription: user@example.com).

Success Message:

If the subscription is successful, the user will see a "Thank you for subscribing!" message.

Error Handling:

If the email is invalid or the request fails, the user will see an error message.

Step 5: Integrate with a Third-Party Service (Optional)
If you want to use a third-party service like Mailchimp or SendGrid to handle subscriptions, replace the backend logic with their API calls.

Example: Using SendGrid
Install SendGrid SDK:

bash
Copy
npm install @sendgrid/mail
Update the Backend:
Replace the subscription logic with SendGrid's API:

javascript
Copy
import express from "express";
import bodyParser from "body-parser";
import sgMail from "@sendgrid/mail";

const app = express();
const PORT = 5000;

app.use(bodyParser.json());

// Set SendGrid API key
sgMail.setApiKey(process.env.SENDGRID_API_KEY);

// Subscription endpoint
app.post("/api/subscribe", (req, res) => {
  const { email } = req.body;

  if (!email || !email.includes("@")) {
    return res.status(400).json({ success: false, message: "Invalid email address." });
  }

  // Send email via SendGrid
  const msg = {
    to: email,
    from: "your-email@example.com", // Replace with your email
    subject: "Subscription Confirmation",
    text: "Thank you for subscribing to AetherSoft Realtors!",
  };

  sgMail
    .send(msg)
    .then(() => {
      console.log("Email sent to:", email);
      res.status(200).json({ success: true, message: "Subscription successful!" });
    })
    .catch((error) => {
      console.error("Error sending email:", error);
      res.status(500).json({ success: false, message: "Failed to subscribe. Please try again later." });
    });
});

// Start server
app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});
Conclusion
Youâ€™ve successfully implemented a subscription feature in the GetStarted component. Users can now enter their email addresses to subscribe, and the data is sent to your backend or a third-party service for processing. Let me know if you need further assistance!


PAYMENT GATEWAY

Step 1: Set Up Payment Gateways
Stripe:

Sign up at Stripe and obtain your API keys (Publishable Key and Secret Key).

Install the Stripe Node.js library:

bash
Copy
npm install stripe
PayPal:

Sign up at PayPal Developer and obtain your Client ID and Secret Key.

Install the PayPal Node.js SDK:

bash
Copy
npm install @paypal/checkout-server-sdk
MTN Mobile Money:

Register with MTN Mobile Money for developers and obtain your API credentials.

Use the MTN Mobile Money API documentation to set up payments.

Pay on Arrival:

No setup is required for this option since it doesnâ€™t involve immediate payment processing.

Step 2: Update the Backend
1. Add Payment Helper Functions
Create helper functions to process payments and refunds for each payment method.

javascript
Copy
import Stripe from 'stripe';
import paypal from '@paypal/checkout-server-sdk';
import axios from 'axios';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
const paypalClient = new paypal.core.PayPalHttpClient(
  new paypal.core.SandboxEnvironment(
    process.env.PAYPAL_CLIENT_ID,
    process.env.PAYPAL_CLIENT_SECRET
  )
);

// Process Stripe Payment
const processStripePayment = async (paymentDetails) => {
  try {
    const paymentIntent = await stripe.paymentIntents.create({
      amount: paymentDetails.amount,
      currency: 'usd',
      payment_method: paymentDetails.paymentMethodId,
      confirm: true,
    });
    return { success: true, paymentIntent };
  } catch (error) {
    return { success: false, error: error.message };
  }
};

// Process PayPal Payment
const processPayPalPayment = async (paymentDetails) => {
  try {
    const request = new paypal.orders.OrdersCreateRequest();
    request.requestBody({
      intent: 'CAPTURE',
      purchase_units: [{
        amount: {
          currency_code: 'USD',
          value: paymentDetails.amount,
        },
      }],
    });
    const response = await paypalClient.execute(request);
    return { success: true, order: response.result };
  } catch (error) {
    return { success: false, error: error.message };
  }
};

// Process MTN Mobile Money Payment
const processMTNMobileMoneyPayment = async (paymentDetails) => {
  try {
    const response = await axios.post('https://api.mtn.com/v1/payments', {
      amount: paymentDetails.amount,
      currency: 'USD',
      phoneNumber: paymentDetails.phoneNumber,
    }, {
      headers: {
        'Authorization': `Bearer ${process.env.MTN_API_KEY}`,
      },
    });
    return { success: true, response: response.data };
  } catch (error) {
    return { success: false, error: error.message };
  }
};

// Refund Stripe Payment
const refundStripePayment = async (paymentIntentId) => {
  try {
    await stripe.refunds.create({
      payment_intent: paymentIntentId,
    });
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
};

// Refund PayPal Payment
const refundPayPalPayment = async (orderId) => {
  try {
    const request = new paypal.orders.OrdersRefundRequest(orderId);
    await paypalClient.execute(request);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
};

// Refund MTN Mobile Money Payment
const refundMTNMobileMoneyPayment = async (transactionId) => {
  try {
    const response = await axios.post(`https://api.mtn.com/v1/refunds`, {
      transactionId,
    }, {
      headers: {
        'Authorization': `Bearer ${process.env.MTN_API_KEY}`,
      },
    });
    return { success: true, response: response.data };
  } catch (error) {
    return { success: false, error: error.message };
  }
};
2. Update the bookVisit Function
Modify the bookVisit function to handle all payment methods, including Pay on Arrival.

javascript
Copy
export const bookVisit = asyncHandler(async (req, res) => {
  const { email, date, time, visitStatus, paymentMethod, paymentDetails } = req.body;
  const id = req.params.id;

  try {
    const user = await prisma.user.findUnique({
      where: { email },
      select: { bookedVisit: true, name: true, telephone: true, address: true },
    });

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    if (user.bookedVisit.some((visit) => visit.id === id)) {
      return res.status(400).json({ message: "You have already booked to visit this property" });
    }

    let paymentResult = { success: true }; // Default for Pay on Arrival
    if (paymentMethod !== 'pay_on_arrival') {
      // Process payment for other methods (Stripe, PayPal, MTN Mobile Money)
      switch (paymentMethod) {
        case 'stripe':
          paymentResult = await processStripePayment(paymentDetails);
          break;
        case 'paypal':
          paymentResult = await processPayPalPayment(paymentDetails);
          break;
        case 'mtn_mobile_money':
          paymentResult = await processMTNMobileMoneyPayment(paymentDetails);
          break;
        default:
          return res.status(400).json({ message: "Invalid payment method" });
      }

      if (!paymentResult.success) {
        return res.status(400).json({ message: "Payment failed", error: paymentResult.error });
      }
    }

    // Proceed with booking
    await prisma.user.update({
      where: { email },
      data: {
        bookedVisit: {
          set: [
            ...(user.bookedVisit || []),
            {
              id,
              date,
              time,
              visitStatus: paymentMethod === 'pay_on_arrival' ? 'pending_payment' : visitStatus || "pending",
              paymentMethod, // Store the payment method
              paymentDetails: paymentMethod !== 'pay_on_arrival' ? paymentResult : null, // Store payment details if applicable
            },
          ],
        },
      },
    });

    // Send confirmation emails (same as before)
    // ...

    res.json({ message: "You have booked to visit the property successfully" });
  } catch (error) {
    console.error("Booking error:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
});
3. Update the cancelBooking Function
Modify the cancelBooking function to handle refunds for all payment methods except Pay on Arrival.

javascript
Copy
export const cancelBooking = asyncHandler(async (req, res) => {
  const { email } = req.body;
  const { id } = req.params;

  try {
    const user = await prisma.user.findUnique({
      where: { email },
      select: { bookedVisit: true, name: true, telephone: true, address: true },
    });

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    const index = user.bookedVisit.findIndex((visit) => visit.id === id);

    if (index === -1) {
      return res.status(404).json({ message: "Booking not found" });
    }

    const booking = user.bookedVisit[index];

    // Check if the booking can be refunded (24 hours or more before the booking time)
    const bookingTime = dayjs(`${booking.date} ${booking.time}`);
    const currentTime = dayjs();
    const timeDifference = bookingTime.diff(currentTime, 'hour');

    if (timeDifference >= 24 && booking.paymentMethod !== 'pay_on_arrival') {
      // Refund logic based on payment method
      switch (booking.paymentMethod) {
        case 'stripe':
          await refundStripePayment(booking.paymentDetails.paymentIntentId);
          break;
        case 'paypal':
          await refundPayPalPayment(booking.paymentDetails.orderId);
          break;
        case 'mtn_mobile_money':
          await refundMTNMobileMoneyPayment(booking.paymentDetails.transactionId);
          break;
        default:
          return res.status(400).json({ message: "Invalid payment method" });
      }
    }

    // Remove the booking
    user.bookedVisit.splice(index, 1);

    await prisma.user.update({
      where: { email },
      data: {
        bookedVisit: user.bookedVisit,
      },
    });

    // Send cancellation emails (same as before)
    // ...

    res.send("Booking cancelled successfully");
  } catch (error) {
    console.error("Error cancelling booking:", error);
    res.status(500).json({ message: "Internal Server Error" });
  }
});
Step 3: Update the Frontend
Add Payment Method Selection:

Add a dropdown or radio button for payment methods, including Pay on Arrival.

Example:

html
Copy
<select name="paymentMethod">
  <option value="stripe">Stripe</option>
  <option value="paypal">PayPal</option>
  <option value="mtn_mobile_money">MTN Mobile Money</option>
  <option value="pay_on_arrival">Pay on Arrival</option>
</select>
Run HTML
Conditional Payment Form:

Show payment details fields (e.g., card number, phone number) only if Pay on Arrival is not selected.

Send Payment Method to Backend:

Include the selected payment method in the request body when booking.

Step 4: Testing
Test Pay on Arrival:

Ensure bookings with Pay on Arrival are created without requiring payment.

Verify that the booking status is set to pending_payment.

Test Refunds:

Ensure refunds are processed correctly for Stripe, PayPal, and MTN Mobile Money.

Verify that no refund is attempted for Pay on Arrival.

Test Emails:

Confirm that emails are sent correctly for all payment methods, including Pay on Arrival.

Step 5: Deployment
Update Environment Variables:

Ensure all API keys and credentials for payment gateways are set in your environment.

Deploy Backend and Frontend:

Deploy the updated backend and frontend code.

Monitor Logs:

Monitor logs for any errors related to payment processing or refunds.

This step-by-step guide ensures that Pay on Arrival is fully integrated into your booking system alongside other payment methods.

MTN MOMO
=================================================
Integrating MTN Mobile Money into your application involves several steps. MTN Mobile Money is a popular mobile payment system in Africa, and integrating it typically requires working with MTN's APIs or a third-party payment gateway that supports MTN Mobile Money. Below is a step-by-step guide to integrating MTN Mobile Money into your application.

Step 1: Choose a Payment Gateway
MTN Mobile Money does not provide a direct public API for developers. Instead, you need to use a third-party payment gateway that supports MTN Mobile Money. Some popular options include:

Flutterwave (supports MTN Mobile Money in multiple countries)

Paystack (supports MTN Mobile Money in specific countries)

Hubtel (supports MTN Mobile Money in Ghana)

For this guide, we'll use Flutterwave as an example.

Step 2: Sign Up for a Flutterwave Account
Go to the Flutterwave website and sign up for an account.

Verify your email and complete the onboarding process.

Obtain your API keys (public and secret keys) from the Flutterwave dashboard.

Step 3: Install Flutterwave SDK
Install the Flutterwave SDK in your frontend and backend.

Frontend (React)
bash
Copy
npm install flutterwave-react-v3
Backend (Node.js)
bash
Copy
npm install flutterwave-node-v3
Step 4: Set Up Flutterwave in the Frontend
In your React frontend, create a component to handle MTN Mobile Money payments using Flutterwave.

Example: MTNMobileMoneyPayment.js
javascript
Copy
import React from "react";
import { useFlutterwave, closePaymentModal } from "flutterwave-react-v3";

const MTNMobileMoneyPayment = ({ onSuccess, onFailure }) => {
  const config = {
    public_key: "YOUR_FLUTTERWAVE_PUBLIC_KEY", // Replace with your Flutterwave public key
    tx_ref: Date.now(), // Unique transaction reference
    amount: 1000, // Amount in the smallest currency unit (e.g., 1000 = 10.00 USD)
    currency: "USD", // Currency code
    payment_options: "mobilemoney", // Specify payment method
    customer: {
      email: "user@example.com", // Replace with the user's email
      phone_number: "233123456789", // Replace with the user's phone number (MTN Mobile Money number)
      name: "John Doe", // Replace with the user's name
    },
    customizations: {
      title: "AetherSoft Realtor",
      description: "Payment for property visit booking",
      logo: "https://your-logo-url.com/logo.png", // Replace with your logo URL
    },
  };

  const handleFlutterwavePayment = useFlutterwave(config);

  const handlePayment = () => {
    handleFlutterwavePayment({
      callback: (response) => {
        if (response.status === "successful") {
          onSuccess(); // Trigger success callback
        } else {
          onFailure(); // Trigger failure callback
        }
        closePaymentModal(); // Close the payment modal
      },
      onClose: () => {
        onFailure(); // Trigger failure callback if the user closes the modal
      },
    });
  };

  return (
    <Button type="primary" onClick={handlePayment}>
      Pay with MTN Mobile Money
    </Button>
  );
};

export default MTNMobileMoneyPayment;
Step 5: Set Up Flutterwave in the Backend
In your Node.js backend, verify the payment using Flutterwave's API.

Example: Verify Payment Endpoint
javascript
Copy
import Flutterwave from "flutterwave-node-v3";

const flutterwave = new Flutterwave(
  "YOUR_FLUTTERWAVE_PUBLIC_KEY", // Replace with your Flutterwave public key
  "YOUR_FLUTTERWAVE_SECRET_KEY" // Replace with your Flutterwave secret key
);

export const verifyPayment = asyncHandler(async (req, res) => {
  const { transactionId } = req.body;

  try {
    // Verify the payment using Flutterwave's API
    const response = await flutterwave.Transaction.verify({ id: transactionId });

    if (
      response.data.status === "successful" &&
      response.data.amount === response.data.charged_amount
    ) {
      // Payment is successful
      res.json({ success: true, message: "Payment verified successfully" });
    } else {
      // Payment failed
      res.status(400).json({ success: false, message: "Payment verification failed" });
    }
  } catch (error) {
    console.error("Payment verification error:", error);
    res.status(500).json({ success: false, message: "Internal Server Error" });
  }
});
Step 6: Update the Booking Modal
Integrate the MTNMobileMoneyPayment component into your booking modal.

Example: BookingModal.js
javascript
Copy
import React, { useContext, useState } from "react";
import { Button, DatePicker, Modal, TimePicker, Select } from "antd";
import UserDetailsContext from "../../context/UserDetailsContext";
import { toast } from "react-toastify";
import dayjs from "dayjs";
import { useMutation } from "react-query";
import { bookVisit } from "../../utils/api";
import { loadStripe } from "@stripe/stripe-js";
import { Elements } from "@stripe/react-stripe-js";
import { PayPalScriptProvider, PayPalButtons } from "@paypal/react-paypal-js";
import StripePayment from "../StripePayment/StripePayment";
import MTNMobileMoneyPayment from "../MTNPayment/MTNMobileMoneyPayment";

// Stripe setup
const stripePromise = loadStripe("pk_test_51N5quMDHDtaIvDO2nmKU2EZnqpoZvT3QUWUFzD79fu6Ht9iPxR2zrv5NJvxMZ98s1lTeRkmuXvTLQz82PEpcHnQB00lIceFH6V");

// PayPal setup
const paypalOptions = {
  "client-id": "ASVLCVJ4a62t_sauBvKf93ifWTkn-4uooOK6Sdnx57USnTnkMADS3mja6sa1zdd8GfuoLUvPQR0aiowv", // Replace with your actual PayPal client ID
  currency: "USD",
};

function BookingModal({ opened, setOpened, email, listingId }) {
  const [date, setDate] = useState(null);
  const [time, setTime] = useState(null);
  const [paymentMethod, setPaymentMethod] = useState("pay_on_arrival");
  const [paymentStatus, setPaymentStatus] = useState("pending");
  const [paypalOrderId, setPaypalOrderId] = useState(null);

  const {
    userDetails: { token },
    setUserDetails,
  } = useContext(UserDetailsContext);

  const { mutate, isLoading } = useMutation({
    mutationFn: ({ paymentMethod, paypalOrderId }) =>
      bookVisit({
        date,
        time,
        listingId,
        email,
        token,
        paymentMethod,
        paymentStatus: paymentMethod === "pay_on_arrival" ? "pending" : "paid",
        paypalOrderId,
      }),
    onSuccess: () => handleBookingSuccess(),
    onError: ({ response }) => toast.error(response.data.message),
    onSettled: () => setOpened(false),
  });

  const handleBookingSuccess = () => {
    toast.success("You have booked your visit", {
      position: "bottom-right",
    });

    setUserDetails((prev) => ({
      ...prev,
      bookings: [
        ...prev.bookings,
        {
          id: listingId,
          date: dayjs(date).format("DD/MM/YYYY"),
          time: dayjs(time).format("HH:mm"),
          visitStatus: "pending",
          bookingStatus: "active",
          paymentStatus,
          paymentMethod,
        },
      ],
    }));
  };

  const handlePaymentSuccess = async (method, orderId = null) => {
    setPaymentStatus("paid");
    setPaymentMethod(method);
    if (method === "paypal") {
      setPaypalOrderId(orderId);
    }
    await mutate({ paymentMethod: method, paypalOrderId: orderId });
  };

  const handlePaymentFailure = () => {
    toast.error("Payment failed. Please try again.");
  };

  return (
    <Modal
      open={opened}
      onCancel={() => setOpened(false)}
      title="Book your visit"
      footer={null}
      centered
    >
      <div style={{ display: "flex", flexDirection: "column", gap: "1rem" }}>
        {/* Date Picker */}
        <DatePicker
          value={date}
          onChange={(date) => setDate(date)}
          disabledDate={(current) => current && current < dayjs().startOf("day")}
          style={{ width: "100%" }}
        />

        {/* Time Picker */}
        <TimePicker
          value={time}
          onChange={(time) => setTime(time)}
          format="HH:mm"
          style={{ width: "100%" }}
        />

        {/* Payment Options */}
        <div>
          <h4>Select Payment Method</h4>
          <Select
            value={paymentMethod}
            onChange={(value) => setPaymentMethod(value)}
            style={{ width: "100%" }}
          >
            <Select.Option value="pay_on_arrival">Pay on Arrival</Select.Option>
            <Select.Option value="stripe">Stripe</Select.Option>
            <Select.Option value="paypal">PayPal</Select.Option>
            <Select.Option value="mtn_mobile_money">MTN Mobile Money</Select.Option>
          </Select>
        </div>

        {/* Stripe Payment */}
        {paymentMethod === "stripe" && (
          <Elements stripe={stripePromise}>
            <StripePayment
              onSuccess={() => handlePaymentSuccess("stripe")}
              onFailure={handlePaymentFailure}
            />
          </Elements>
        )}

        {/* PayPal Payment */}
        {paymentMethod === "paypal" && (
          <PayPalScriptProvider options={paypalOptions}>
            <PayPalButtons
              createOrder={(data, actions) => {
                return actions.order.create({
                  purchase_units: [
                    {
                      amount: {
                        value: "10.00", // Replace with actual amount
                      },
                    },
                  ],
                });
              }}
              onApprove={(data, actions) => {
                return actions.order.capture().then((details) => {
                  handlePaymentSuccess("paypal", details.id); // Pass PayPal order ID
                });
              }}
              onError={handlePaymentFailure}
            />
          </PayPalScriptProvider>
        )}

        {/* MTN Mobile Money Payment */}
        {paymentMethod === "mtn_mobile_money" && (
          <MTNMobileMoneyPayment
            onSuccess={() => handlePaymentSuccess("mtn_mobile_money")}
            onFailure={handlePaymentFailure}
          />
        )}

        {/* Book Visit Button */}
        <Button
          type="primary"
          disabled={
            !date ||
            !time ||
            isLoading ||
            (paymentMethod !== "pay_on_arrival" && paymentStatus !== "paid")
          }
          loading={isLoading}
          onClick={() => mutate({ paymentMethod, paypalOrderId })}
          style={{ width: "100%", marginTop: "1rem" }}
        >
          Book visit
        </Button>
      </div>
    </Modal>
  );
}

export default BookingModal;
Step 7: Test the Integration
MTN Mobile Money:

Use a test MTN Mobile Money number to simulate payments.

Ensure the payment is verified in the backend.

Stripe and PayPal:

Test the Stripe and PayPal payment flows as usual.

Pay on Arrival:

Ensure the pay_on_arrival option works as expected.

This step-by-step guide ensures a seamless integration of MTN Mobile Money into your application. Let me know if you need further assistance!

   
